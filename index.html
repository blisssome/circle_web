<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Circular Wrist/Elbow Revolution Tester</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh; display: flex; justify-content: center; align-items: center; color: #fff;
    }
    .container {
      background: rgba(255,255,255,0.1); backdrop-filter: blur(10px);
      border-radius: 20px; padding: 24px; width: min(420px, 92vw);
      text-align: center; box-shadow: 0 8px 32px rgba(0,0,0,0.12);
      border: 1px solid rgba(255,255,255,0.2);
    }
    h1 { font-size: 22px; font-weight: 700; margin-bottom: 12px; }
    .status { padding: 12px; border-radius: 10px; margin: 12px 0; font-weight: 600; border: 1px solid rgba(255,255,255,0.35); }
    .status.active { background: rgba(76,175,80,0.18); border-color: rgba(76,175,80,0.55); }
    .status.detecting { background: rgba(255,193,7,0.2); border-color: rgba(255,193,7,0.6); animation: pulse 1.5s infinite; }
    @keyframes pulse { 0%,100%{transform:scale(1)} 50%{transform:scale(1.02)} }

    /* Visual area: canvas + overlay dot */
    .visual {
      position: relative; width: 280px; height: 280px; margin: 14px auto 10px;
      border-radius: 50%; border: 2px solid rgba(255,255,255,0.28);
      background: rgba(255,255,255,0.06);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,0.08);
      overflow: hidden;
    }
    canvas#pathCanvas { width: 100%; height: 100%; display: block; }
    #gyroDot {
      position: absolute; width: 10px; height: 10px; border-radius: 50%;
      background: #4CAF50; top: 50%; left: 50%; transform: translate(-50%,-50%);
      box-shadow: 0 0 0 2px rgba(0,0,0,0.12);
      transition: transform 0.06s linear;
    }

    .confidence-bar { width: 100%; height: 18px; background: rgba(255,255,255,0.2);
      border-radius: 10px; overflow: hidden; margin: 8px 0; }
    .confidence-fill { height: 100%; width: 0%; background: linear-gradient(90deg,#4CAF50,#FFC107,#FF5722);
      border-radius: 10px; transition: width .2s ease; }
    .data-display { background: rgba(0,0,0,0.22); border-radius: 10px; padding: 10px; margin-top: 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 12px; text-align: left; }
    .detection-history { max-height: 160px; overflow-y: auto; background: rgba(0,0,0,0.22); border-radius: 10px; padding: 10px; margin-top: 12px; text-align: left; }
    .detection-item { padding: 4px 0; border-bottom: 1px solid rgba(255,255,255,0.12); font-size: 13px; }
    button {
      background: rgba(255,255,255,0.18); border: 1px solid rgba(255,255,255,0.34); color: #fff;
      padding: 10px 18px; border-radius: 22px; cursor: pointer; font-size: 15px; margin: 8px 6px;
      transition: all .15s ease;
    }
    button:hover { background: rgba(255,255,255,0.28); transform: translateY(-1px); }
    button:active { transform: translateY(0); }
    #debugInfo { margin-top: 6px; font: 12px ui-monospace, monospace; opacity: .9; text-align: left; white-space: pre-wrap; }
  </style>
</head>
<body>
  <div class="container">
    <h1>üîÑ Circular Wrist/Elbow Tester</h1>

    <div id="status" class="status">Tap ‚ÄúStart Detection‚Äù, then hold still 1s</div>

    <div class="visual">
      <canvas id="pathCanvas"></canvas>
      <div id="gyroDot"></div>
    </div>

    <div class="confidence-bar">
      <div id="confidenceBar" class="confidence-fill"></div>
    </div>
    <div id="confidenceText">Revolution progress: 0%</div>

    <div>
      <button id="startBtn" onclick="startDetection()">Start Detection</button>
      <button id="stopBtn" onclick="stopDetection()" style="display:none;">Stop Detection</button>
      <button onclick="clearHistory()">Clear History</button>
    </div>

    <div class="data-display">
      <div>Planar acceleration (|a‚üÇg|): <span id="planarA">0.00</span> m/s¬≤</div>
    </div>

    <div class="detection-history">
      <strong>Detection History:</strong>
      <div id="history"></div>
    </div>

    <!-- Debug line will appear here if enabled -->
    <div id="debugInfo" style="display:none;"></div>
  </div>

  <script>
    // ---------- Toggle debug text (shows gate, a, œâ, radius, veto) ----------
    const DEBUG = false;

    // ---------- Math helpers ----------
    const TAU = Math.PI * 2;
    const DEG = Math.PI / 180;
    const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
    const unwrap = d => (d > Math.PI ? d - TAU : d < -Math.PI ? d + TAU : d);
    const hypot3 = (x,y,z)=>Math.sqrt(x*x + y*y + z*z);
    function cross(a,b){ return {x:a.y*b.z - a.z*b.y, y:a.z*b.x - a.x*b.z, z:a.x*b.y - a.y*b.x}; }
    function norm(v){ const n=hypot3(v.x,v.y,v.z)||1; return {x:v.x/n,y:v.y/n,z:v.z/n}; }
    function median(arr){ if(!arr.length) return 0; const s=[...arr].sort((a,b)=>a-b); const m=Math.floor(s.length/2); return s.length%2?s[m]:(s[m-1]+s[m])/2; }
    function mad(arr, m=null){ if(!arr.length) return 0; if(m==null) m=median(arr); const dev=arr.map(x=>Math.abs(x-m)); return median(dev); }

    class CalibratedWristDetector {
      constructor(canvas, dotEl){
        // --- UI / canvas wiring ---
        this.canvas = canvas; this.ctx = canvas.getContext('2d'); this.dotEl = dotEl;
        this.dpr = Math.max(1, window.devicePixelRatio||1);
        window.addEventListener('resize', () => { this.resize(); this.resetCanvas(); }, {passive:true});
        this.resize(); this.resetCanvas();

        // --- Detection targets ---
        this.progressTarget   = TAU * 0.80;  // ~288¬∞ = "almost full"
        this.segMinDur        = 0.25;        // s
        this.segMaxDur        = 12.0;        // s
        this.signCoherenceMin = 0.60;        // mostly one direction
        this.rMin = 0.04;                    // m
        this.rMax = 0.50;                    // m
        this.rWin = 0.8;                     // s window for radius stability
        this.rCoVMax = 0.60;                 // robust CoV

        // Anti spin-in-place (gyro yaw veto) ‚Äî set high so it won't block normal moves
        this.yawSpinVeto      = 160;         // deg/s about gravity
        this.spinLinearThresh = 0.7;         // m/s¬≤

        // Gravity + smoothing
        this.gTau = 0.25;                    // s
        this.betaMs = 0.10;                  // ~100ms smoothing for planar vector

        // State
        this.g = null; this.lastT = 0;
        this.uLP = 0; this.vLP = 0;
        this.prevTheta = null;
        this.theta = 0; this.thetaStart = 0; this.progress = 0;
        this.posDur = 0; this.negDur = 0;
        this.segStartT = null; this.lastGoodMs = 0; this.gapMsAllow = 350;

        this.rBuf = [];
        this.lastDetectMs = 0; this.cooldownMs = 1500;

        // Calibration + hysteresis thresholds (will be set from noise)
        this.calibrating = true; this.calibStart = 0; this.calibA = []; this.calibW = [];
        this.accPlanarMin = 0.10;  // ON thresholds (start gate)
        this.accPlanarOff = 0.07;  // OFF thresholds (keep gate)
        this.omegaMin = 0.20;
        this.omegaOff = 0.14;
        this.gateOpen = false;

        // Dot easing
        this.uiAlpha = 0.25; this._uiX = 0; this._uiY = 0;

        // Debug label
        this.debugEl = document.getElementById('debugInfo');
        if (DEBUG && this.debugEl) this.debugEl.style.display = 'block';

        // Start calibration
        this._startCalibration();
      }

      // ---------- Layout ----------
      resize(){
        const cw=this.canvas.clientWidth, ch=this.canvas.clientHeight;
        this.canvas.width = Math.floor(cw*this.dpr);
        this.canvas.height= Math.floor(ch*this.dpr);
        this.w=this.canvas.width; this.h=this.canvas.height;
        this.cx=this.w/2; this.cy=this.h/2;

        this.padPx=6*this.dpr;
        this.R = Math.min(this.cx,this.cy) - this.padPx;   // drawable radius
        this.rRing = this.R * 0.60;                        // ring when gated
        this.rIdle = Math.max(4, this.R * 0.06);           // tiny ring when idle

        this.ctx.setTransform(1,0,0,1,0,0);
        this.ctx.lineWidth=2*this.dpr;
        this.ctx.lineCap='round'; this.ctx.lineJoin='round';
        this.ctx.strokeStyle='rgba(255,255,255,0.95)';
      }

      resetCanvas(){
        this.ctx.clearRect(0,0,this.w,this.h);
        // outline
        this.ctx.save(); this.ctx.globalAlpha=.18;
        this.ctx.beginPath(); this.ctx.arc(this.cx,this.cy,this.R,0,TAU); this.ctx.stroke(); this.ctx.restore();
        // clip
        this.ctx.save(); this.ctx.beginPath(); this.ctx.arc(this.cx,this.cy,this.R - this.ctx.lineWidth*0.5, 0, TAU); this.ctx.clip();
        this.pathStarted=false;

        // state reset
        this.prevTheta=null; this.theta=0; this.thetaStart=0;
        this.progress=0; this.posDur=0; this.negDur=0;
        this.segStartT=null; this.lastGoodMs=0; this.rBuf.length=0;
        this._lastXPix=this.cx; this._lastYPix=this.cy;
        this._renderProgress(); this._moveDot();
      }

      // ---------- Calibration ----------
      _startCalibration(){
        this.calibrating = true;
        this.calibA.length=0; this.calibW.length=0; this.calibStart = performance.now();
        const st=document.getElementById('status');
        if (st){ st.textContent='Calibrating‚Ä¶ hold still for 1s'; st.className='status'; }
      }
      _maybeFinishCalibration(now){
        if (!this.calibrating) return;
        if (now - this.calibStart < 1000) return; // 1s
        const aMed=median(this.calibA), aMAD=mad(this.calibA, aMed)*1.4826;
        const wMed=median(this.calibW), wMAD=mad(this.calibW, wMed)*1.4826;

        // Clamp calibration so ‚Äúnoisy start‚Äù can‚Äôt brick the gate
        const aMin = Math.max(0.10, aMed + 4*aMAD);
        const aOff = Math.max(0.06, aMed + 3*aMAD);
        const wMin = Math.max(0.18, wMed + 4*wMAD);
        const wOff = Math.max(0.12, wMed + 3*wMAD);

        this.accPlanarMin = Math.min(0.35, aMin);
        this.accPlanarOff = Math.min(0.25, aOff);
        this.omegaMin     = Math.min(0.90, wMin);
        this.omegaOff     = Math.min(0.70, wOff);

        this.calibrating = false;
        const st=document.getElementById('status');
        if (st){ st.textContent='Listening‚Ä¶ draw a small wrist/elbow circle'; st.className='status active'; }
      }

      // ---------- Main pipeline ----------
      addSample(acc, accG, rr){
        const now = performance.now();
        const dt = this.lastT ? Math.max(0.001,(now - this.lastT)/1000) : 0.016;
        this.lastT = now;

        // Gravity init/update (robust)
        if (!this.g) {
          if (accG && Number.isFinite(accG.x)) {
            this.g = {x:accG.x, y:accG.y, z:accG.z};
          } else if (acc && Number.isFinite(acc.x)) {
            const mag = hypot3(acc.x,acc.y,acc.z);
            if (mag > 7.5) this.g = {x:acc.x, y:acc.y, z:acc.z}; else return;
          } else { return; }
        } else {
          const a = Math.exp(-dt/this.gTau);
          if (accG && Number.isFinite(accG.x)) {
            this.g.x = a*this.g.x + (1-a)*accG.x;
            this.g.y = a*this.g.y + (1-a)*accG.y;
            this.g.z = a*this.g.z + (1-a)*accG.z;
          }
        }

        // Linear accel & projection into plane ‚üÇ gravity
        let ax=0, ay=0, az=0;
        if (acc && Number.isFinite(acc.x)) { ax=acc.x; ay=acc.y; az=acc.z; }
        else if (accG) { ax=accG.x - this.g.x; ay=accG.y - this.g.y; az=accG.z - this.g.z; }

        const gn = norm(this.g);
        const ref = Math.abs(gn.z)<0.9 ? {x:0,y:0,z:1} : {x:1,y:0,z:0};
        const e1 = norm(cross(gn,ref)), e2 = cross(gn,e1);

        const dotg = ax*gn.x + ay*gn.y + az*gn.z;
        const px = ax - dotg*gn.x, py = ay - dotg*gn.y, pz = az - dotg*gn.z;

        const u = px*e1.x + py*e1.y + pz*e1.z;
        const v = px*e2.x + py*e2.y + pz*e2.z;

        // Smooth planar vector (keeps dot calm)
        const beta = Math.exp(-dt/this.betaMs);
        this.uLP = beta*this.uLP + (1-beta)*u;
        this.vLP = beta*this.vLP + (1-beta)*v;

        const aPlanar = Math.hypot(this.uLP, this.vLP);
        const thetaNow = Math.atan2(this.vLP, this.uLP);
        if (this.prevTheta==null) this.prevTheta = thetaNow;
        const dtheta = unwrap(thetaNow - this.prevTheta);
        const omega = Math.abs(dtheta)/dt;

        // Draw path on ring (gate = big ring, idle = tiny ring)
        const ring = this.gateOpen ? this.rRing : this.rIdle;
        const x = this.cx + ring*Math.cos(thetaNow);
        const y = this.cy + ring*Math.sin(thetaNow);
        if (!this.pathStarted) { this.ctx.beginPath(); this.ctx.moveTo(x,y); this.pathStarted=true; }
        else { this.ctx.lineTo(x,y); this.ctx.stroke(); }
        this._lastXPix=x; this._lastYPix=y; this._moveDot();

        // Calibration samples
        if (this.calibrating) {
          this.calibA.push(aPlanar);
          this.calibW.push(omega);
          this._maybeFinishCalibration(now);
          this.prevTheta = thetaNow;
          const p = document.getElementById('planarA'); if (p) p.textContent = aPlanar.toFixed(2);
          return;
        }

        // Gyro yaw (for spin veto only)
        let yawDeg = 0;
        if (rr) yawDeg = (rr.beta||0)*gn.x + (rr.gamma||0)*gn.y + (rr.alpha||0)*gn.z;
        const spinVeto = Math.abs(yawDeg) > this.yawSpinVeto && aPlanar < this.spinLinearThresh;

        // Radius stability (centripetal r ‚âà a/œâ¬≤)
        let rInst = (omega>1e-6) ? aPlanar/(omega*omega + 1e-9) : Infinity;
        this._pushRadius(now, rInst);
        const rStats = this._radiusStats(now);
        const radiusOk = rStats.valid &&
                         rStats.med >= this.rMin && rStats.med <= this.rMax &&
                         rStats.cov <= this.rCoVMax;

        // ---- Hysteresis gate (RELAXED): allow progress when (radius OK) OR (accel above floor) ----
        if (!this.gateOpen) {
          this.gateOpen = !spinVeto && (omega >= this.omegaMin) && (radiusOk || aPlanar >= this.accPlanarMin);
          if (this.gateOpen) { this.segStartT=now; this.thetaStart=this.theta; this.posDur=0; this.negDur=0; }
        } else {
          const gateKeep = !spinVeto && (omega >= this.omegaOff) && (radiusOk || aPlanar >= this.accPlanarOff);
          if (!gateKeep) {
            this.lastGoodMs = this.lastGoodMs || now;
            if (now - this.lastGoodMs > this.gapMsAllow) {
              this.gateOpen = false; this._resetSegment(now); this.lastGoodMs = 0;
            }
          } else {
            this.lastGoodMs = 0;
          }
        }

        // Debug line
        if (DEBUG && this.debugEl) {
          const progPct = Math.round(this.progress*100);
          this.debugEl.textContent =
            `gate:${this.gateOpen?'1':'0'} prog:${progPct}% ` +
            `a:${aPlanar.toFixed(2)} (min:${this.accPlanarMin.toFixed(2)}/${this.accPlanarOff.toFixed(2)}) ` +
            `œâ:${(omega/DEG).toFixed(0)}¬∞/s (min:${(this.omegaMin/DEG).toFixed(0)}/${(this.omegaOff/DEG).toFixed(0)}) ` +
            `r:${isFinite(rInst)?rInst.toFixed(2):'‚àû'} med:${rStats.med.toFixed(2)} cov:${rStats.cov.toFixed(2)} ` +
            `yaw:${yawDeg.toFixed(0)} veto:${spinVeto?'Y':'N'}`;
        }

        // Integrate angle & check detection only while gate is open
        if (this.gateOpen) {
          this.theta += dtheta;
          if (dtheta>0) this.posDur += dt; else if (dtheta<0) this.negDur += dt;

          const prevProg = this.progress;
          const traveled = Math.abs(this.theta - this.thetaStart);
          this.progress = Math.min(1, traveled / this.progressTarget);
          this._renderProgress();

          if (prevProg < 1 && this.progress >= 1) this._maybeDetect(now, rStats);
        } else {
          // gentle decay so bar doesn't "stick"
          this.progress = Math.max(0, this.progress - 0.015);
          this._renderProgress();
        }

        // UI readout
        const p = document.getElementById('planarA'); if (p) p.textContent = aPlanar.toFixed(2);
        this.prevTheta = thetaNow;
      }

      _pushRadius(t, r){
        const start = t - this.rWin*1000;
        if (isFinite(r)) this.rBuf.push({t, r: clamp(r, 0, 10)});
        while (this.rBuf.length && this.rBuf[0].t < start) this.rBuf.shift();
      }
      _radiusStats(t){
        const start = t - this.rWin*1000;
        const arr = this.rBuf.filter(x=>x.t>=start).map(x=>x.r);
        if (arr.length < 6) return {valid:false, med:0, cov:1};
        const med = median(arr);
        const m = mad(arr, med)*1.4826;
        const cov = med>1e-6 ? m/med : 1;
        return {valid:true, med, cov};
      }

      _maybeDetect(now, rStats){
        const dur = this.segStartT ? (now - this.segStartT)/1000 : 0;
        const totalTurn = this.posDur + this.negDur;
        const signCoh = totalTurn>0 ? Math.max(this.posDur, this.negDur)/totalTurn : 0;
        const cooled = (now - this.lastDetectMs) > this.cooldownMs;

        if (dur>=this.segMinDur && dur<=this.segMaxDur &&
            signCoh >= this.signCoherenceMin &&
            rStats.valid && rStats.cov <= this.rCoVMax && cooled) {
          this.lastDetectMs = now;
          this._onDetected();
          this._resetSegment(now);
        }
      }

      _resetSegment(now){
        this.thetaStart = this.theta;
        this.progress = 0; this.posDur=0; this.negDur=0;
        this._renderProgress();
      }

      _renderProgress(){
        const pct = Math.round(this.progress*100);
        const bar = document.getElementById('confidenceBar');
        const txt = document.getElementById('confidenceText');
        if (bar) bar.style.width = pct + '%';
        if (txt) txt.textContent = `Revolution progress: ${pct}%`;
      }

      _moveDot(){
        const x = (this._lastXPix ?? this.cx), y = (this._lastYPix ?? this.cy);
        const cssW=this.canvas.clientWidth, cssH=this.canvas.clientHeight;
        const cssX=(x/this.dpr) - cssW/2, cssY=(y/this.dpr) - cssH/2;
        this._uiX += this.uiAlpha*(cssX - this._uiX);
        this._uiY += this.uiAlpha*(cssY - this._uiY);
        this.dotEl.style.transform = `translate(calc(-50% + ${this._uiX}px), calc(-50% + ${this._uiY}px))`;
      }

      _onDetected(){
        // flash background
        document.body.style.background='linear-gradient(135deg, #4CAF50 0%, #45a049 100%)';
        setTimeout(()=>{ document.body.style.background='linear-gradient(135deg, #667eea 0%, #764ba2 100%)'; }, 700);

        // status
        const status=document.getElementById('status');
        if (status){ status.textContent='üéâ FULL REVOLUTION'; status.className='status detecting';
          setTimeout(()=>{ status.textContent='Listening‚Ä¶ draw a small wrist/elbow circle'; status.className='status active'; }, 1500); }

        // history
        const history=document.getElementById('history');
        if (history){ const div=document.createElement('div'); div.className='detection-item';
          div.textContent=new Date().toLocaleTimeString()+': Full revolution'; history.appendChild(div); }

        if ('vibrate' in navigator) navigator.vibrate([160,100,160]);
        console.log('‚úÖ Full revolution detected');
      }
    }

    // ---------- Wiring ----------
    let detector=null, isActive=false;

    function startDetection(){
      if (typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function') {
        DeviceMotionEvent.requestPermission()
          .then(state=>{ if(state==='granted') start(); else alert('Motion permission denied.'); })
          .catch(e=>{ console.error(e); alert('Permission request failed.'); });
      } else { start(); }
    }
    function start(){
      if (isActive) return;
      detector = new CalibratedWristDetector(
        document.getElementById('pathCanvas'),
        document.getElementById('gyroDot')
      );
      window.addEventListener('devicemotion', onMotion, {passive:true});
      isActive = true;

      const st=document.getElementById('status');
      if (st){ st.textContent='Calibrating‚Ä¶ hold still for 1s'; st.className='status'; }
      document.getElementById('startBtn').style.display='none';
      document.getElementById('stopBtn').style.display='inline-block';
    }
    function stopDetection(){
      if (!isActive) return;
      window.removeEventListener('devicemotion', onMotion);
      isActive=false;
      const st=document.getElementById('status');
      if (st){ st.textContent='Detection stopped'; st.className='status'; }
      document.getElementById('startBtn').style.display='inline-block';
      document.getElementById('stopBtn').style.display='none';
    }
    function onMotion(e){
      detector.addSample(
        e.acceleration || null,
        e.accelerationIncludingGravity || null,
        e.rotationRate || null   // only used for spin veto
      );
    }
    function clearHistory(){
      const h=document.getElementById('history'); if(h) h.innerHTML='';
      document.getElementById('confidenceBar').style.width='0%';
      document.getElementById('confidenceText').textContent='Revolution progress: 0%';
      if (detector) detector.resetCanvas();
    }

    // Optional: allow tap on debug line to toggle visibility
    if (DEBUG) { const d=document.getElementById('debugInfo'); if (d) d.style.display='block'; }
    console.log('üì± Ready. Start ‚Üí 1s still ‚Üí draw a smooth wrist/elbow circle.');
  </script>
</body>
</html>
