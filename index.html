<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Short-Motion Tracer (IMU)</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh; display:flex; align-items:center; justify-content:center; color:#fff;
    }
    .container {
      background: rgba(255,255,255,0.1); backdrop-filter: blur(10px);
      border-radius: 20px; padding: 24px; width: 92%; max-width: 420px; text-align:center;
      border: 1px solid rgba(255,255,255,0.2); box-shadow: 0 8px 32px rgba(0,0,0,0.15);
    }
    h1 { font-size:22px; font-weight:600; margin-bottom:12px; }
    .status { margin:12px 0; padding:12px; border-radius:10px; transition:.2s;
      border:1px solid rgba(255,255,255,0.35); background: rgba(0,0,0,0.2); }
    .status.active { border-color: rgba(76,175,80,0.6); background: rgba(76,175,80,0.15); }
    .status.detecting { border-color: rgba(255,193,7,0.6); background: rgba(255,193,7,0.15); }

    .gyro-visual {
      width: 220px; height: 220px; margin: 16px auto; position: relative;
      border-radius: 50%; border: 2px solid rgba(255,255,255,0.3);
      background: rgba(255,255,255,0.06);
      overflow: hidden;
    }
    #pathCanvas {
      position: absolute; inset: 0; width: 100%; height: 100%;
      border-radius: 50%; pointer-events: none;
    }
    .gyro-dot {
      width: 10px; height: 10px; border-radius: 50%;
      background: #4CAF50; position: absolute;
      top: 50%; left: 50%; transform: translate(-50%,-50%);
      box-shadow: 0 0 8px rgba(0,0,0,0.25);
    }

    .confidence-bar { width:100%; height: 10px; background: rgba(255,255,255,0.25);
      border-radius: 10px; overflow: hidden; margin: 8px 0 4px; }
    .confidence-fill { height: 100%; width:0%; background: rgba(255,255,255,0.9); transition: width .15s; }
    .data-display { font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      font-size:12px; text-align:left; background: rgba(0,0,0,0.25); border-radius:10px; padding:10px; margin-top:12px; }
    button {
      background: rgba(255,255,255,0.2); border:1px solid rgba(255,255,255,0.35);
      color:#fff; padding:10px 16px; border-radius: 999px; cursor:pointer; margin: 6px;
    }
    button:hover { background: rgba(255,255,255,0.3); transform: translateY(-1px); }
  </style>
</head>
<body>
  <div class="container">
    <h1>üåÄ Short-Motion Wrist Tracer</h1>
    <div id="status" class="status">Tap ‚ÄúStart‚Äù and draw a small circle with your wrist</div>

    <div class="gyro-visual">
      <canvas id="pathCanvas"></canvas>
      <div id="gyroDot" class="gyro-dot"></div>
    </div>

    <div class="confidence-bar"><div id="confidenceBar" class="confidence-fill"></div></div>
    <div id="confidenceText" style="font-size:12px;opacity:.9;">Path activity: 0%</div>

    <div>
      <button id="startBtn" onclick="startDetection()">Start</button>
      <button id="stopBtn" onclick="stopDetection()" style="display:none;">Stop</button>
      <button onclick="clearHistory()">Clear</button>
    </div>

    <div class="data-display">
      <div>Gyro (deg/s): <span id="gyroData">X: 0, Y: 0, Z: 0</span></div>
      <div>Planar accel (m/s¬≤): <span id="planarA">0.00</span></div>
      <div>Radius (est, cm): <span id="radiusEst">0</span></div>
    </div>

    <div class="data-display" style="margin-top:8px; max-height:140px; overflow:auto;">
      <strong>History</strong>
      <div id="history"></div>
    </div>
  </div>

  <script>
    const TAU = Math.PI * 2;
    const DEG = Math.PI / 180;
    function cross(a,b){ return {x:a.y*b.z - a.z*b.y, y:a.z*b.x - a.x*b.z, z:a.x*b.y - a.y*b.x}; }
    function norm(v){ const n = Math.hypot(v.x,v.y,v.z)||1; return {x:v.x/n,y:v.y/n,z:v.z/n}; }
  
    class ShortMotionTracer {
      constructor(canvas, dotEl){
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.dotEl = dotEl;
        this.dpr = Math.max(1, window.devicePixelRatio || 1);
        window.addEventListener('resize', () => { this.resize(); this.resetCanvas(); }, {passive:true});
  
        // Gravity LPF
        this.g = null;
        this.gTau = 0.25;          // s
        this.gUpdateGyroMax = 60;  // deg/s
  
        // Circle model & gates
        this.omegaMin = 35 * DEG;  // rad/s about gravity
        this.accPlanarMin = 1.1;   // m/s^2
        this.rMin = 0.03;          // meters
        this.rMax = 0.50;          // meters
  
        // Progress / detection
        this.progress = 0;
        this.progressTarget = TAU * 0.92; // ~330¬∞
        this.theta = 0;
        this.thetaStart = 0;
        this.posDur = 0; this.negDur = 0;
        this.signCoherenceMin = 0.80;     // slightly relaxed
        this.segStartT = null;
        this.segMinDur = 0.30;            // wider acceptance
        this.segMaxDur = 6.00;
        this.gapMsAllow = 280;            // tolerate short interruptions
  
        // Radius estimate smoothing
        this.rLP = null;
        this.rLPalpha = 0.2;
  
        // UI/path state
        this._lastXPix = null; this._lastYPix = null;
        this.uiX = 0; this.uiY = 0; this.uiAlpha = 0.25;
  
        // Debounce detection
        this.lastDetection = 0;
        this.cooldownMs = 2000;
  
        this.resize();
        this.resetCanvas();
      }
  
      resize(){
        const cw = this.canvas.clientWidth, ch = this.canvas.clientHeight;
        this.canvas.width = Math.floor(cw * this.dpr);
        this.canvas.height = Math.floor(ch * this.dpr);
        this.w = this.canvas.width; this.h = this.canvas.height;
        this.cx = this.w/2; this.cy = this.h/2;
  
        // Compute drawable circle radius (inside the round frame)
        this.padPx = 6 * this.dpr;                 // inner padding
        this.R = Math.min(this.cx, this.cy) - this.padPx; // max pixel radius for path/dot
  
        // Map meters -> pixels so rMax fits exactly inside the circle
        this.pxPerMeter = this.R / this.rMax;
  
        // Canvas styles
        this.ctx.setTransform(1,0,0,1,0,0);
        this.ctx.lineWidth = 2*this.dpr;
        this.ctx.lineCap='round'; this.ctx.lineJoin='round';
        this.ctx.strokeStyle = 'rgba(255,255,255,0.95)';
        this.ctx.fillStyle = 'rgba(255,255,255,0.95)';
      }
  
      resetCanvas(){
        this.ctx.clearRect(0,0,this.w,this.h);
  
        // Draw the boundary circle
        this.ctx.save();
        this.ctx.globalAlpha = 0.18;
        this.ctx.beginPath(); this.ctx.arc(this.cx, this.cy, this.R, 0, TAU);
        this.ctx.stroke();
        this.ctx.restore();
  
        // Set a clip so path can never draw outside
        this.ctx.save();
        this.ctx.beginPath(); this.ctx.arc(this.cx, this.cy, this.R - this.ctx.lineWidth*0.5, 0, TAU);
        this.ctx.clip();
        this.pathStarted = false;
  
        // Reset path/detection state
        this.progress = 0; this.theta = 0; this.thetaStart = 0;
        this.posDur = 0; this.negDur = 0; this.segStartT = null; this.rLP = null;
        this._renderProgress();
        this._lastXPix = null; this._lastYPix = null;
        this._moveDot(); // re-center dot
        // Note: we keep the clipping active (ctx.restore() not called) until next reset
      }
  
      addSample(wx_deg, wy_deg, wz_deg, acc, accG){
        const now = performance.now();
        const dt = (this._lastT ? Math.max(0.001, (now - this._lastT)/1000) : 0.016);
        this._lastT = now;
  
        // Gravity LPF
        if (accG) {
          if (!this.g) this.g = {x:accG.x||0, y:accG.y||0, z:accG.z||0};
          const gyroMag = Math.hypot(wx_deg,wy_deg,wz_deg);
          if (gyroMag < this.gUpdateGyroMax) {
            const alpha = Math.exp(-dt/this.gTau);
            this.g.x = alpha*this.g.x + (1-alpha)*(accG.x||0);
            this.g.y = alpha*this.g.y + (1-alpha)*(accG.y||0);
            this.g.z = alpha*this.g.z + (1-alpha)*(accG.z||0);
          }
        }
        if (!this.g) return;
  
        // Linear accel (prefer e.acceleration)
        let ax=0, ay=0, az=0;
        if (acc && [acc.x,acc.y,acc.z].every(v => typeof v === 'number')) {
          ax=acc.x||0; ay=acc.y||0; az=acc.z||0;
        } else if (accG) {
          ax=(accG.x||0)-this.g.x; ay=(accG.y||0)-this.g.y; az=(accG.z||0)-this.g.z;
        }
  
        // World plane ‚üÇ gravity
        const gn = norm(this.g);
        const ref = (Math.abs(gn.z) < 0.9) ? {x:0,y:0,z:1} : {x:1,y:0,z:0};
        const e1 = norm(cross(gn, ref));   // plane axis #1
        const e2 = cross(gn, e1);          // plane axis #2
  
        // Planar acceleration
        const dotg = ax*gn.x + ay*gn.y + az*gn.z;
        const px = ax - dotg*gn.x, py = ay - dotg*gn.y, pz = az - dotg*gn.z;
        const u = px*e1.x + py*e1.y + pz*e1.z;
        const v = px*e2.x + py*e2.y + pz*e2.z;
        const aPlanar = Math.hypot(u,v);
  
        // Angular velocity about plane normal (rad/s)
        const w_par = (wx_deg*gn.x + wy_deg*gn.y + wz_deg*gn.z) * DEG;
  
        // --- Gate: only integrate when it looks like a circle ---
        const gate = Math.abs(w_par) >= this.omegaMin && aPlanar >= this.accPlanarMin;
  
        // UI text
        document.getElementById('gyroData').textContent =
          `X: ${wx_deg.toFixed(1)}, Y: ${wy_deg.toFixed(1)}, Z: ${wz_deg.toFixed(1)}`;
        document.getElementById('planarA').textContent = aPlanar.toFixed(2);
  
        if (gate) {
          // radius estimate r=a/œâ¬≤ (clamped)
          const rEst = Math.max(this.rMin, Math.min(this.rMax, aPlanar / (w_par*w_par + 1e-6)));
          this.rLP = (this.rLP==null) ? rEst : (this.rLP + this.rLPalpha*(rEst - this.rLP));
  
          // start a segment when gate first opens
          if (this.segStartT == null) {
            this.segStartT = now;
            this.thetaStart = this.theta;
            this.posDur = 0; this.negDur = 0;
          }
  
          // integrate angle
          const dtheta = w_par * dt;
          this.theta += dtheta;
          if (dtheta > 0) this.posDur += dt; else if (dtheta < 0) this.negDur += dt;
  
          // progress since segment start
          const traveled = Math.abs(this.theta - this.thetaStart);
          this.progress = Math.min(1, traveled / this.progressTarget);
          this._renderProgress();
  
          // draw point (CLAMP into circle radius)
          this._drawPoint(this.theta, this.rLP);
  
          // detection check
          this._maybeDetect(now);
        } else {
          // brief gate drops allowed; longer gaps reset the segment
          this._maybePauseOrReset(now);
        }
  
        // Move green dot to the last drawn pixel position (same coords as path)
        this._moveDot();
      }
  
      _maybeDetect(now){
        if (this.progress < 1) return;
        const dur = this.segStartT ? (now - this.segStartT)/1000 : 0;
        const totalTurn = this.posDur + this.negDur;
        const signCoh = totalTurn > 0 ? Math.max(this.posDur, this.negDur) / totalTurn : 0;
        const cooled = (now - this.lastDetection) > this.cooldownMs;
        const withinDur = (dur >= this.segMinDur && dur <= this.segMaxDur);
  
        if (cooled && withinDur && signCoh >= this.signCoherenceMin) {
          this.lastDetection = now;
          this._onDetected();
          this._resetSegment(now);
        }
      }
  
      _maybePauseOrReset(nowMs){
        if (this.segStartT != null) {
          this._gapStart = this._gapStart ?? nowMs;
          if ((nowMs - this._gapStart) > this.gapMsAllow) {
            this._resetSegment(nowMs);
            this._gapStart = null;
          }
        }
        // decay progress display slightly so 100% doesn't ‚Äústick‚Äù
        this.progress = Math.max(0, this.progress - 0.02);
        this._renderProgress();
      }
  
      _resetSegment(nowMs){
        this.segStartT = null;
        this.thetaStart = this.theta; // keep absolute theta for continuity
        this.progress = 0;
        this.posDur = 0; this.negDur = 0;
        this.rLP = null;
        this._renderProgress();
      }
  
      _renderProgress(){
        const pct = Math.round(this.progress * 100);
        document.getElementById('confidenceBar').style.width = pct + '%';
        document.getElementById('confidenceText').textContent = `Revolution progress: ${pct}%`;
      }
  
      _drawPoint(theta, rMeters){
        // Convert meters -> pixels and clamp to drawable circle radius
        const rPix = Math.max(0, Math.min(this.R, rMeters * this.pxPerMeter));
        const x = this.cx + rPix * Math.cos(theta);
        const y = this.cy + rPix * Math.sin(theta);
  
        if (!this.pathStarted) { this.ctx.beginPath(); this.ctx.moveTo(x,y); this.pathStarted = true; }
        else { this.ctx.lineTo(x,y); this.ctx.stroke(); }
  
        this._lastXPix = x; this._lastYPix = y; // store exact pixel coords used for drawing
      }
  
      _moveDot(){
        // Use the same pixel coordinates as the path, translated to CSS space
        const x = (this._lastXPix ?? this.cx), y = (this._lastYPix ?? this.cy);
        const cssW = this.canvas.clientWidth, cssH = this.canvas.clientHeight;
        const cssX = (x/this.dpr) - cssW/2;
        const cssY = (y/this.dpr) - cssH/2;
        this.uiX += this.uiAlpha * (cssX - this.uiX);
        this.uiY += this.uiAlpha * (cssY - this.uiY);
        this.dotEl.style.transform = `translate(calc(-50% + ${this.uiX}px), calc(-50% + ${this.uiY}px))`;
      }
  
      _onDetected(){
        // Visual flash + status
        document.body.style.background = 'linear-gradient(135deg, #4CAF50 0%, #45a049 100%)';
        setTimeout(() => { document.body.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)'; }, 700);
  
        const status = document.getElementById('status');
        status.textContent = 'üéâ FULL WRIST REVOLUTION';
        status.className = 'status detecting';
        if ('vibrate' in navigator) navigator.vibrate([180,100,180]);
        setTimeout(() => { status.textContent = 'Listening‚Ä¶ draw a small wrist circle'; status.className = 'status active'; }, 1500);
  
        // History entry (ensure the element exists)
        const history = document.getElementById('history');
        if (history) {
          const div = document.createElement('div');
          div.className = 'detection-item';
          div.textContent = new Date().toLocaleTimeString() + ': Full revolution';
          history.appendChild(div);
        }
      }
    }
  
    // ------- Wire up to DeviceMotion -------
    let tracer = null, isActive = false;
  
    function startDetection(){
      const needsPerm = typeof DeviceMotionEvent !== 'undefined' &&
                        typeof DeviceMotionEvent.requestPermission === 'function';
      if (needsPerm) {
        DeviceMotionEvent.requestPermission()
          .then(state => { if (state === 'granted') start(); else alert('Motion permission denied.'); })
          .catch(e => { console.error(e); alert('Permission request failed.'); });
      } else { start(); }
    }
  
    function start(){
      if (isActive) return;
      tracer = new ShortMotionTracer(
        document.getElementById('pathCanvas'),
        document.getElementById('gyroDot')
      );
      window.addEventListener('devicemotion', onMotion, { passive: true });
      isActive = true;
  
      document.getElementById('status').textContent = 'Listening‚Ä¶ draw a small wrist circle';
      document.getElementById('status').className = 'status active';
      document.getElementById('startBtn').style.display = 'none';
      document.getElementById('stopBtn').style.display = 'inline-block';
    }
  
    function stopDetection(){
      if (!isActive) return;
      window.removeEventListener('devicemotion', onMotion);
      isActive = false;
  
      document.getElementById('status').textContent = 'Detection stopped';
      document.getElementById('status').className = 'status';
      document.getElementById('startBtn').style.display = 'inline-block';
      document.getElementById('stopBtn').style.display = 'none';
    }
  
    function onMotion(e){
      const rr = e.rotationRate || {};
      tracer.addSample(
        rr.beta  || 0,   // X (deg/s)
        rr.gamma || 0,   // Y (deg/s)
        rr.alpha || 0,   // Z (deg/s)
        e.acceleration || null,
        e.accelerationIncludingGravity || null
      );
    }
  
    function clearHistory(){
      const h = document.getElementById('history');
      if (h) h.innerHTML = '';
      document.getElementById('confidenceBar').style.width = '0%';
      document.getElementById('confidenceText').textContent = 'Revolution progress: 0%';
      if (tracer) tracer.resetCanvas();
    }
  
    window.addEventListener('load', () => {
      console.log('‚úÖ Path and dot are now clamped inside the circle (with clipping).');
      console.log('‚úÖ Detection posts to history when progress completes with good coherence/duration.');
    });
  </script>
  
  
</body>
</html>
