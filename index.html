<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Rapid Wrist/Elbow Circle ‚Äî Accel-Angle Bandpass (No Prompts)</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  body{
    font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;
    background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);
    min-height:100vh;display:flex;justify-content:center;align-items:center;color:#fff
  }
  .container{
    background:rgba(255,255,255,.1);backdrop-filter:blur(10px);
    border-radius:20px;padding:24px;width:min(420px,92vw);text-align:center;
    box-shadow:0 8px 32px rgba(0,0,0,.12);border:1px solid rgba(255,255,255,.2)
  }
  h1{font-size:22px;font-weight:700;margin-bottom:12px}
  .status{padding:12px;border-radius:10px;margin:12px 0;font-weight:600;border:1px solid rgba(255,255,255,.35)}
  .status.active{background:rgba(76,175,80,.18);border-color:rgba(76,175,80,.55)}
  .status.detecting{background:rgba(255,193,7,.2);border-color:rgba(255,193,7,.6);animation:pulse 1.5s infinite}
  @keyframes pulse{0%,100%{transform:scale(1)}50%{transform:scale(1.02)}}
  .visual{
    position:relative;width:280px;height:280px;margin:14px auto 10px;border-radius:50%;
    border:2px solid rgba(255,255,255,.28);background:rgba(255,255,255,.06);
    box-shadow:inset 0 0 0 2px rgba(255,255,255,.08);overflow:hidden
  }
  canvas#pathCanvas{width:100%;height:100%;display:block}
  #gyroDot{
    position:absolute;width:10px;height:10px;border-radius:50%;
    background:#4CAF50;top:50%;left:50%;transform:translate(-50%,-50%);
    box-shadow:0 0 0 2px rgba(0,0,0,.12);transition:transform .06s linear
  }
  .confidence-bar{width:100%;height:18px;background:rgba(255,255,255,.2);border-radius:10px;overflow:hidden;margin:8px 0}
  .confidence-fill{height:100%;width:0%;background:linear-gradient(90deg,#4CAF50,#FFC107,#FF5722);border-radius:10px;transition:width .18s ease}
  .data-display{background:rgba(0,0,0,.22);border-radius:10px;padding:10px;margin-top:10px;
    font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,'Liberation Mono',monospace;font-size:12px;text-align:left}
  .detection-history{max-height:160px;overflow-y:auto;background:rgba(0,0,0,.22);border-radius:10px;padding:10px;margin-top:12px;text-align:left}
  .detection-item{padding:4px 0;border-bottom:1px solid rgba(255,255,255,.12);font-size:13px}
  button{
    background:rgba(255,255,255,.18);border:1px solid rgba(255,255,255,.34);color:#fff;
    padding:10px 18px;border-radius:22px;cursor:pointer;font-size:15px;margin:8px 6px;transition:all .15s ease
  }
  button:hover{background:rgba(255,255,255,.28);transform:translateY(-1px)}
  button:active{transform:translateY(0)}
  #sensorNotice{display:none;margin-top:8px;padding:10px;border-radius:10px;background:rgba(255,107,107,.18);border:1px solid rgba(255,107,107,.5);font-size:13px;text-align:left}
</style>
</head>
<body>
  <div class="container">
    <h1>üîÑ Rapid Wrist/Elbow Circle (No Prompts)</h1>

    <div id="status" class="status">Tap ‚ÄúStart‚Äù, hold still 1s, then do ONE quick circle</div>

    <div class="visual">
      <canvas id="pathCanvas"></canvas>
      <div id="gyroDot"></div>
    </div>

    <div class="confidence-bar"><div id="confidenceBar" class="confidence-fill"></div></div>
    <div id="confidenceText">Revolution progress: 0%</div>

    <div>
      <button id="startBtn" onclick="startDetection()">Start</button>
      <button id="stopBtn" onclick="stopDetection()" style="display:none;">Stop</button>
      <button onclick="clearHistory()">Clear History</button>
    </div>

    <div class="data-display">
      <div>|a‚üÇg| bandpass (m/s¬≤): <span id="aBP">0.00</span></div>
      <div>œÜÃá (deg/s): <span id="omegaPhi">0</span></div>
      <div>coherence: <span id="coh">0.00</span></div>
      <div>valid%: <span id="vfrac">0%</span></div>
    </div>

    <div class="detection-history">
      <strong>Detection History:</strong>
      <div id="history"></div>
    </div>

    <div id="sensorNotice">
      <strong>No motion data received.</strong><br>
      iPhone/iPad: Safari ‚Üí ‚ÄúaA‚Äù ‚Üí Website Settings ‚Üí Motion & Orientation Access ‚Üí ON, then reload.<br>
      Android Chrome: lock icon ‚Üí Site settings ‚Üí Motion sensors ‚Üí Allow.
    </div>
  </div>

<script>
/* ------------- No-permission version ------------- */
const TAU = Math.PI*2, DEG = Math.PI/180;
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
const unwrap=d=>(d>Math.PI?d-TAU:d<-Math.PI?d+TAU:d);
const hypot3=(x,y,z)=>Math.sqrt(x*x+y*y+z*z);
function cross(a,b){return {x:a.y*b.z-a.z*b.y,y:a.z*b.x-a.x*b.z,z:a.x*b.y-a.y*b.x};}
function norm(v){const n=hypot3(v.x,v.y,v.z)||1;return {x:v.x/n,y:v.y/n,z:v.z/n};}
function median(a){if(!a.length)return 0;const s=[...a].sort((x,y)=>x-y);const m=Math.floor(s.length/2);return s.length%2?s[m]:(s[m-1]+s[m])/2;}
function mad(a,m=null){if(!a.length)return 0;if(m==null)m=median(a);const d=a.map(x=>Math.abs(x-m));return median(d);}

class RapidCircleDetector {
  constructor(canvas,dot){
    /* ---- tuned for ‚Äúone quick circle‚Äù ---- */
    this.progressTarget = TAU * 0.90;   // need ~324¬∞ of rotation
    this.segMinDur = 0.15;              // super fast allowed
    this.segMaxDur = 2.20;              // must be ‚Äúrapid‚Äù
    this.gapMsAllow = 180;              // short drop tolerance

    // band-pass for accel in plane: ~0.5‚Äì6 Hz
    this.hpTau = 0.28;                  // ~0.57 Hz
    this.lpTau = 0.06;                  // ~2.6 Hz (keeps it snappy)

    // gating
    this.aBPmin = 0.45;                 // m/s¬≤ min bandpassed magnitude to count
    this.omegaPhiMin = 1.3;             // rad/s (~75¬∞/s) turning speed floor
    this.omegaPhiOff = 1.0;             // hysteresis

    // directional consistency
    this.cohTau = 0.6;                  // EWMA window ~0.6s
    this.cohMin = 0.65;                 // mostly one way

    // segment-level validity requirements
    this.minValidFrac = 0.55;           // ‚â•55% of samples ‚Äúvalid‚Äù
    this.minAvgABP    = 0.55;           // average bandpass amplitude over segment

    // canvas & UI
    this.canvas=canvas; this.ctx=canvas.getContext('2d'); this.dot=dot;
    this.dpr=Math.max(1,window.devicePixelRatio||1);
    this.uiAlpha=0.25; this._uiX=0; this._uiY=0;

    // state
    this.lastT=0; this.g=null;
    this.uPrev=0; this.vPrev=0;         // for HP filter
    this.uHP=0; this.vHP=0;             // high-pass state
    this.uBP=0; this.vBP=0;             // low-pass (bandpass output)

    this.prevPhi=null; this.turnAbs=0; this.progress=0;
    this.segStart=null; this.lastGoodMs=0;
    this.posEW=0; this.negEW=0;

    // segment stats
    this.validCount=0; this.totalCount=0; this.sumABP=0;

    // calibration (noise floors) ‚Äî 1s
    this.calibrating=true; this.calibStart=performance.now(); this.calA=[]; this.calPhiDot=[];
    this._setupCanvas();
  }

  _setupCanvas(){
    const cw=this.canvas.clientWidth, ch=this.canvas.clientHeight;
    this.canvas.width=Math.floor(cw*this.dpr);
    this.canvas.height=Math.floor(ch*this.dpr);
    this.w=this.canvas.width; this.h=this.canvas.height;
    this.cx=this.w/2; this.cy=this.h/2;
    this.padPx=6*this.dpr;
    this.R=Math.min(this.cx,this.cy)-this.padPx;
    this.rDraw=this.R*0.70;
    this.ctx.setTransform(1,0,0,1,0,0);
    this.ctx.lineWidth=2*this.dpr; this.ctx.lineCap='round'; this.ctx.lineJoin='round';
    this.ctx.strokeStyle='rgba(255,255,255,.95)';
    this._resetCanvas();
    window.addEventListener('resize',()=>this._setupCanvas(),{passive:true});
  }
  _resetCanvas(){
    this.ctx.clearRect(0,0,this.w,this.h);
    this.ctx.save(); this.ctx.globalAlpha=.18;
    this.ctx.beginPath(); this.ctx.arc(this.cx,this.cy,this.R,0,TAU); this.ctx.stroke(); this.ctx.restore();
    this.ctx.save(); this.ctx.beginPath(); this.ctx.arc(this.cx,this.cy,this.R - this.ctx.lineWidth*0.5,0,TAU); this.ctx.clip();
    this.pathStarted=false;

    this.prevPhi=null; this.turnAbs=0; this.progress=0;
    this.segStart=null; this.lastGoodMs=0;
    this.posEW=this.negEW=0;
    this.validCount=this.totalCount=this.sumABP=0;

    this._lastXPix=this.cx; this._lastYPix=this.cy;
    this._renderProgress(); this._moveDot();
  }

  addSample(acc,accG){
    const now=performance.now();
    const dt=this.lastT?Math.max(0.001,(now-this.lastT)/1000):0.016;
    this.lastT=now;

    // gravity estimate (LPF on incl. gravity)
    if(!this.g){
      if(accG && Number.isFinite(accG.x)) this.g={x:accG.x,y:accG.y,z:accG.z};
      else if(acc && Number.isFinite(acc.x)){ const m=hypot3(acc.x,acc.y,acc.z); if(m>7.5) this.g={x:acc.x,y:acc.y,z:acc.z}; else return; }
      else return;
    } else {
      const a=Math.exp(-dt/0.25);
      if(accG && Number.isFinite(accG.x)){
        this.g.x=a*this.g.x+(1-a)*accG.x; this.g.y=a*this.g.y+(1-a)*accG.y; this.g.z=a*this.g.z+(1-a)*accG.z;
      }
    }

    // linear accel (remove gravity) ‚Üí plane ‚üÇ g
    let ax=0,ay=0,az=0;
    if(acc && Number.isFinite(acc.x)){ ax=acc.x; ay=acc.y; az=acc.z; }
    else if(accG){ ax=accG.x-this.g.x; ay=accG.y-this.g.y; az=accG.z-this.g.z; }

    const gn=norm(this.g);
    const ref=Math.abs(gn.z)<0.9?{x:0,y:0,z:1}:{x:1,y:0,z:0};
    const e1=norm(cross(gn,ref)), e2=cross(gn,e1);

    const dotg=ax*gn.x+ay*gn.y+az*gn.z;
    const px=ax-dotg*gn.x, py=ay-dotg*gn.y, pz=az-dotg*gn.z;

    let u=px*e1.x+py*e1.y+pz*e1.z;
    let v=px*e2.x+py*e2.y+pz*e2.z;

    // -------- band-pass (HP then LP) --------
    // High-pass: y = Œ±*(y + x - x_prev), Œ± = œÑ/(œÑ+dt)
    const aHP = this.hpTau/(this.hpTau+dt);
    this.uHP = aHP*(this.uHP + u - this.uPrev);
    this.vHP = aHP*(this.vHP + v - this.vPrev);
    this.uPrev = u; this.vPrev = v;

    // Low-pass on HP output: y = exp(-dt/œÑ)*y + (1-exp(-dt/œÑ))*x
    const aLP = Math.exp(-dt/this.lpTau);
    this.uBP = aLP*this.uBP + (1-aLP)*this.uHP;
    this.vBP = aLP*this.vBP + (1-aLP)*this.vHP;

    const aBPmag = Math.hypot(this.uBP,this.vBP);

    // angle of band-passed acceleration (centripetal direction)
    const phi = Math.atan2(this.vBP, this.uBP);
    if(this.prevPhi==null) this.prevPhi=phi;
    const dphi = unwrap(phi - this.prevPhi);
    this.prevPhi = phi;

    const phiDot = Math.abs(dphi)/dt; // rad/s

    // draw on fixed ring (clean)
    const x=this.cx + this.rDraw*Math.cos(phi);
    const y=this.cy + this.rDraw*Math.sin(phi);
    if(!this.pathStarted){ this.ctx.beginPath(); this.ctx.moveTo(x,y); this.pathStarted=true; }
    else { this.ctx.lineTo(x,y); this.ctx.stroke(); }
    this._lastXPix=x; this._lastYPix=y; this._moveDot();

    // calibration (1s): set floors gently above noise, then go
    if(this.calibrating){
      this.calA.push(aBPmag); this.calPhiDot.push(phiDot);
      if(now - this.calibStart > 1000){
        const aMed=median(this.calA), aMAD=mad(this.calA,aMed)*1.4826;
        const wMed=median(this.calPhiDot), wMAD=mad(this.calPhiDot,wMed)*1.4826;
        this.aBPmin = Math.min(0.70, Math.max(0.35, aMed + 6*aMAD));
        this.omegaPhiMin = Math.min(2.2, Math.max(1.0, wMed + 5*wMAD));  // demand *rapid* turning
        this.omegaPhiOff = Math.max(0.8, this.omegaPhiMin*0.75);
        this.calibrating=false;
        const st=document.getElementById('status'); if(st){st.textContent='Listening‚Ä¶ do ONE quick circle'; st.className='status active';}
      }
      this._hud(aBPmag, phiDot, 0.5, 0);
      return;
    }

    // validity & coherence
    const enoughSpeed = phiDot >= (this.segStart?this.omegaPhiOff:this.omegaPhiMin);
    const valid = (aBPmag >= this.aBPmin) && enoughSpeed;

    // coherence EWMA (directional consistency)
    const cDecay = Math.exp(-dt/this.cohTau);
    this.posEW = cDecay*this.posEW + Math.max(0, dphi);
    this.negEW = cDecay*this.negEW + Math.max(0,-dphi);
    const coh = (this.posEW+this.negEW)>1e-6 ? Math.max(this.posEW,this.negEW)/(this.posEW+this.negEW) : 0.5;

    // segment logic
    this.totalCount++;
    if(valid) this.validCount++, this.sumABP += aBPmag;

    if(valid && coh >= this.cohMin){
      if(!this.segStart){ this.segStart=now; this.turnAbs=0; this.validCount=1; this.totalCount=1; this.sumABP=aBPmag; this.posEW=this.negEW=0; }
      this.turnAbs += Math.abs(dphi);

      const prevProg=this.progress;
      this.progress = Math.min(1, this.turnAbs / this.progressTarget);
      this._renderProgress();

      if(prevProg<1 && this.progress>=1){
        const dur=(now - this.segStart)/1000;
        const vfrac = this.validCount/Math.max(1,this.totalCount);
        const avgA  = this.sumABP/Math.max(1,this.validCount);
        const cooled = true; // very short cooldown not necessary for single-turn
        if(dur>=this.segMinDur && dur<=this.segMaxDur &&
           vfrac>=this.minValidFrac && avgA>=this.minAvgABP &&
           coh>=this.cohMin && cooled){
          this._onDetected();
          this._resetSegment();
        }
      }
      this.lastGoodMs = now;
    } else {
      if(this.segStart){
        if(!this.lastGoodMs) this.lastGoodMs=now;
        if((now - this.lastGoodMs) > this.gapMsAllow){ this._resetSegment(); this.lastGoodMs=0; }
        this.progress = Math.max(0, this.progress - 0.02);
        this._renderProgress();
      }
    }

    this._hud(aBPmag, phiDot, coh, (this.validCount/Math.max(1,this.totalCount)));
  }

  _resetSegment(){
    this.segStart=null; this.turnAbs=0; this.progress=0;
    this.validCount=0; this.totalCount=0; this.sumABP=0;
    this._renderProgress();
  }

  _renderProgress(){
    const pct=Math.round(this.progress*100);
    const bar=document.getElementById('confidenceBar');
    const txt=document.getElementById('confidenceText');
    if(bar) bar.style.width=pct+'%';
    if(txt) txt.textContent=`Revolution progress: ${pct}%`;
  }
  _moveDot(){
    const x=(this._lastXPix??this.cx), y=(this._lastYPix??this.cy);
    const cssW=this.canvas.clientWidth, cssH=this.canvas.clientHeight;
    const cssX=(x/this.dpr)-cssW/2, cssY=(y/this.dpr)-cssH/2;
    this._uiX+=0.25*(cssX-this._uiX);
    this._uiY+=0.25*(cssY-this._uiY);
    this.dot.style.transform=`translate(calc(-50% + ${this._uiX}px), calc(-50% + ${this._uiY}px))`;
  }
  _hud(aBP,phiDot,coh,vfrac){
    const a=document.getElementById('aBP'); if(a) a.textContent=aBP.toFixed(2);
    const w=document.getElementById('omegaPhi'); if(w) w.textContent=((phiDot/DEG)|0);
    const c=document.getElementById('coh'); if(c) c.textContent=coh.toFixed(2);
    const vf=document.getElementById('vfrac'); if(vf) vf.textContent=Math.round(vfrac*100)+'%';
  }
  _onDetected(){
    document.body.style.background='linear-gradient(135deg,#4CAF50 0%,#45a049 100%)';
    setTimeout(()=>{document.body.style.background='linear-gradient(135deg,#667eea 0%,#764ba2 100%)';},600);
    const s=document.getElementById('status');
    if(s){ s.textContent='üéâ 1 rapid revolution'; s.className='status detecting';
      setTimeout(()=>{ s.textContent='Listening‚Ä¶ do ONE quick circle'; s.className='status active'; },1200); }
    const h=document.getElementById('history');
    if(h){ const div=document.createElement('div'); div.className='detection-item';
      div.textContent=new Date().toLocaleTimeString()+': Rapid circle detected'; h.appendChild(div); }
    if('vibrate' in navigator) navigator.vibrate([140,80,140]);
  }
}

/* -------- wiring (no permission prompts) -------- */
let det=null,isActive=false,probeTimer=null;
function startDetection(){
  if(isActive) return;
  det=new RapidCircleDetector(document.getElementById('pathCanvas'),document.getElementById('gyroDot'));
  window.addEventListener('devicemotion', onMotion, {passive:true});
  isActive=true;
  const st=document.getElementById('status'); if(st){st.textContent='Calibrating‚Ä¶ hold still 1s'; st.className='status';}
  document.getElementById('startBtn').style.display='none';
  document.getElementById('stopBtn').style.display='inline-block';

  // probe: show inline tip if no events in 2s
  let got=false;
  const probe=()=>{got=true;window.removeEventListener('devicemotion',probe);};
  window.addEventListener('devicemotion',probe,{passive:true});
  clearTimeout(probeTimer);
  probeTimer=setTimeout(()=>{ if(!got) document.getElementById('sensorNotice').style.display='block'; },2000);
}
function stopDetection(){
  if(!isActive) return;
  window.removeEventListener('devicemotion', onMotion);
  isActive=false;
  const st=document.getElementById('status'); if(st){st.textContent='Detection stopped'; st.className='status';}
  document.getElementById('startBtn').style.display='inline-block';
  document.getElementById('stopBtn').style.display='none';
}
function onMotion(e){
  det.addSample(e.acceleration || null, e.accelerationIncludingGravity || null);
}
function clearHistory(){
  const h=document.getElementById('history'); if(h) h.innerHTML='';
  document.getElementById('confidenceBar').style.width='0%';
  document.getElementById('confidenceText').textContent='Revolution progress: 0%';
  if(det) det._resetCanvas();
}
</script>
</body>
</html>
