<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Enhanced Circular Motion Detector</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  body{
    font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;
    background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);
    min-height:100vh;display:flex;justify-content:center;align-items:center;color:#fff
  }
  .container{
    background:rgba(255,255,255,.1);backdrop-filter:blur(10px);
    border-radius:20px;padding:24px;width:min(420px,92vw);text-align:center;
    box-shadow:0 8px 32px rgba(0,0,0,.12);border:1px solid rgba(255,255,255,.2)
  }
  h1{font-size:22px;font-weight:700;margin-bottom:12px}
  .status{padding:12px;border-radius:10px;margin:12px 0;font-weight:600;border:1px solid rgba(255,255,255,.35)}
  .status.active{background:rgba(76,175,80,.18);border-color:rgba(76,175,80,.55)}
  .status.detecting{background:rgba(255,193,7,.2);border-color:rgba(255,193,7,.6);animation:pulse 1.5s infinite}
  @keyframes pulse{0%,100%{transform:scale(1)}50%{transform:scale(1.02)}}
  .visual{
    position:relative;width:280px;height:280px;margin:14px auto 10px;border-radius:50%;
    border:2px solid rgba(255,255,255,.28);background:rgba(255,255,255,.06);
    box-shadow:inset 0 0 0 2px rgba(255,255,255,.08);overflow:hidden
  }
  canvas#pathCanvas{width:100%;height:100%;display:block}
  #motionDot{
    position:absolute;width:12px;height:12px;border-radius:50%;
    background:#4CAF50;top:50%;left:50%;transform:translate(-50%,-50%);
    box-shadow:0 0 0 2px rgba(0,0,0,.12);transition:transform .08s ease
  }
  .progress-bar{width:100%;height:18px;background:rgba(255,255,255,.2);border-radius:10px;overflow:hidden;margin:8px 0}
  .progress-fill{height:100%;width:0%;background:linear-gradient(90deg,#4CAF50,#FFC107,#FF5722);border-radius:10px;transition:width .2s ease}
  .data-display{background:rgba(0,0,0,.22);border-radius:10px;padding:12px;margin-top:12px;
    font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,'Liberation Mono',monospace;font-size:12px;text-align:left}
  .data-row{display:flex;justify-content:space-between;margin:4px 0}
  .detection-history{max-height:160px;overflow-y:auto;background:rgba(0,0,0,.22);border-radius:10px;padding:10px;margin-top:12px;text-align:left}
  .detection-item{padding:4px 0;border-bottom:1px solid rgba(255,255,255,.12);font-size:13px}
  button{
    background:rgba(255,255,255,.18);border:1px solid rgba(255,255,255,.34);color:#fff;
    padding:10px 18px;border-radius:22px;cursor:pointer;font-size:15px;margin:8px 6px;transition:all .15s ease
  }
  button:hover{background:rgba(255,255,255,.28);transform:translateY(-1px)}
  button:active{transform:translateY(0)}
  #sensorNotice{display:none;margin-top:8px;padding:10px;border-radius:10px;background:rgba(255,107,107,.18);border:1px solid rgba(255,107,107,.5);font-size:13px;text-align:left}
  .circle-indicator{
    position:absolute;
    top:10px;
    left:10px;
    width:20px;
    height:20px;
    border:2px solid rgba(255,255,255,.4);
    border-radius:50%;
    border-top:2px solid #4CAF50;
    display:none;
    animation:spin 1s linear infinite;
  }
  @keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
</style>
</head>
<body>
  <div class="container">
    <h1>ðŸ”„ Enhanced Circular Motion Detector</h1>

    <div id="status" class="status">Hold phone steady, move your arm in circles</div>

    <div class="visual">
      <canvas id="pathCanvas"></canvas>
      <div id="motionDot"></div>
      <div id="circleIndicator" class="circle-indicator"></div>
    </div>

    <div class="progress-bar"><div id="progressBar" class="progress-fill"></div></div>
    <div id="progressText">Circular motion: 0%</div>

    <div>
      <button id="startBtn" onclick="startDetection()">Start Detection</button>
      <button id="stopBtn" onclick="stopDetection()" style="display:none;">Stop</button>
      <button onclick="clearHistory()">Clear History</button>
    </div>

    <div class="data-display">
      <div class="data-row"><span>Centripetal Accel:</span> <span id="centripetal">0.00 m/sÂ²</span></div>
      <div class="data-row"><span>Angular Velocity:</span> <span id="angularVel">0 Â°/s</span></div>
      <div class="data-row"><span>Circle Quality:</span> <span id="quality">0%</span></div>
      <div class="data-row"><span>Motion Energy:</span> <span id="energy">0.00</span></div>
      <div class="data-row"><span>Radius Est:</span> <span id="radius">0 cm</span></div>
    </div>

    <div class="detection-history">
      <strong>Detection History:</strong>
      <div id="history"></div>
    </div>

    <div id="sensorNotice">
      <strong>No motion data received.</strong><br>
      iPhone/iPad: Safari â†’ "aA" â†’ Website Settings â†’ Motion & Orientation Access â†’ ON, then reload.<br>
      Android Chrome: lock icon â†’ Site settings â†’ Motion sensors â†’ Allow.
    </div>
  </div>

<script>
const TAU = Math.PI * 2;
const DEG = 180 / Math.PI;

class CircularMotionDetector {
  constructor(canvas, dot, indicator) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.dot = dot;
    this.indicator = indicator;
    
    // Detection parameters
    this.minCircleTime = 0.5;      // Minimum time for one circle (seconds)
    this.maxCircleTime = 3.0;      // Maximum time for one circle
    this.minRadius = 0.15;         // Minimum radius in meters
    this.maxRadius = 0.8;          // Maximum radius in meters
    this.qualityThreshold = 0.7;   // Minimum circle quality (0-1)
    this.minCentripetalAccel = 1.0; // Minimum centripetal acceleration
    
    // State variables
    this.isCalibrating = true;
    this.calibrationStart = 0;
    this.gravity = null;
    this.lastTime = 0;
    this.motionHistory = [];
    this.maxHistoryLength = 150; // ~3 seconds at 50Hz
    
    // Circular motion tracking
    this.circleProgress = 0;
    this.currentAngle = 0;
    this.lastAngle = null;
    this.totalRotation = 0;
    this.circleStartTime = 0;
    this.centerX = 0;
    this.centerY = 0;
    this.estimatedRadius = 0;
    
    // Smoothing
    this.smoothedAccel = { x: 0, y: 0 };
    this.smoothedVel = { x: 0, y: 0 };
    this.smoothingFactor = 0.1;
    
    this._setupCanvas();
    this._resetDetection();
  }
  
  _setupCanvas() {
    const rect = this.canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    
    this.canvas.width = rect.width * dpr;
    this.canvas.height = rect.height * dpr;
    this.ctx.scale(dpr, dpr);
    
    this.canvasWidth = rect.width;
    this.canvasHeight = rect.height;
    this.centerX = this.canvasWidth / 2;
    this.centerY = this.canvasHeight / 2;
    this.maxRadius = Math.min(this.canvasWidth, this.canvasHeight) * 0.4;
    
    this.ctx.lineWidth = 2;
    this.ctx.lineCap = 'round';
    this._clearCanvas();
  }
  
  _clearCanvas() {
    this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
    
    // Draw reference circle
    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
    this.ctx.beginPath();
    this.ctx.arc(this.centerX, this.centerY, this.maxRadius * 0.8, 0, TAU);
    this.ctx.stroke();
    
    // Reset path
    this.pathStarted = false;
  }
  
  _resetDetection() {
    this.circleProgress = 0;
    this.totalRotation = 0;
    this.lastAngle = null;
    this.circleStartTime = 0;
    this.motionHistory = [];
    this.estimatedRadius = 0;
    this._updateProgress();
    this._clearCanvas();
  }
  
  addMotionSample(acceleration, accelerationGravity, rotationRate, timestamp) {
    const now = timestamp || performance.now();
    const dt = this.lastTime ? (now - this.lastTime) / 1000 : 1/60;
    this.lastTime = now;
    
    // Establish gravity vector
    if (!this.gravity && accelerationGravity) {
      this.gravity = {
        x: accelerationGravity.x,
        y: accelerationGravity.y,
        z: accelerationGravity.z
      };
      return;
    }
    
    if (!this.gravity) return;
    
    // Update gravity estimate with low-pass filter
    if (accelerationGravity) {
      const alpha = 0.02;
      this.gravity.x = (1 - alpha) * this.gravity.x + alpha * accelerationGravity.x;
      this.gravity.y = (1 - alpha) * this.gravity.y + alpha * accelerationGravity.y;
      this.gravity.z = (1 - alpha) * this.gravity.z + alpha * accelerationGravity.z;
    }
    
    // Calculate linear acceleration (remove gravity)
    let linearAccel = { x: 0, y: 0, z: 0 };
    if (acceleration) {
      linearAccel = acceleration;
    } else if (accelerationGravity) {
      linearAccel = {
        x: accelerationGravity.x - this.gravity.x,
        y: accelerationGravity.y - this.gravity.y,
        z: accelerationGravity.z - this.gravity.z
      };
    }
    
    // Smooth the acceleration
    this.smoothedAccel.x = (1 - this.smoothingFactor) * this.smoothedAccel.x + this.smoothingFactor * linearAccel.x;
    this.smoothedAccel.y = (1 - this.smoothingFactor) * this.smoothedAccel.y + this.smoothingFactor * linearAccel.y;
    
    // Estimate velocity by integration (with decay to prevent drift)
    const velocityDecay = 0.95;
    this.smoothedVel.x = this.smoothedVel.x * velocityDecay + this.smoothedAccel.x * dt;
    this.smoothedVel.y = this.smoothedVel.y * velocityDecay + this.smoothedAccel.y * dt;
    
    // Calculate motion metrics
    const accelMagnitude = Math.sqrt(linearAccel.x**2 + linearAccel.y**2 + linearAccel.z**2);
    const planarAccelMag = Math.sqrt(this.smoothedAccel.x**2 + this.smoothedAccel.y**2);
    const velMagnitude = Math.sqrt(this.smoothedVel.x**2 + this.smoothedVel.y**2);
    
    // Store motion history
    const motionSample = {
      time: now,
      accel: { x: linearAccel.x, y: linearAccel.y },
      smoothAccel: { x: this.smoothedAccel.x, y: this.smoothedAccel.y },
      velocity: { x: this.smoothedVel.x, y: this.smoothedVel.y },
      accelMag: planarAccelMag,
      velMag: velMagnitude
    };
    
    this.motionHistory.push(motionSample);
    if (this.motionHistory.length > this.maxHistoryLength) {
      this.motionHistory.shift();
    }
    
    // Calibration phase
    if (this.isCalibrating) {
      if (this.calibrationStart === 0) {
        this.calibrationStart = now;
      }
      
      if (now - this.calibrationStart > 1000) { // 1 second calibration
        this.isCalibrating = false;
        const status = document.getElementById('status');
        if (status) {
          status.textContent = 'Ready! Move your arm in circles';
          status.className = 'status active';
        }
      }
      this._updateHUD(planarAccelMag, 0, 0, 0, 0);
      return;
    }
    
    // Detect circular motion
    this._detectCircularMotion(motionSample, dt);
    
    // Update visualization
    this._updateVisualization(motionSample);
  }
  
  _detectCircularMotion(sample, dt) {
    if (this.motionHistory.length < 10) return;
    
    // Calculate instantaneous center of circular motion
    const recent = this.motionHistory.slice(-20); // Last 20 samples
    let centerX = 0, centerY = 0, radius = 0, quality = 0;
    
    if (recent.length >= 3) {
      // Estimate circular motion parameters
      const result = this._estimateCircleParams(recent);
      centerX = result.centerX;
      centerY = result.centerY;
      radius = result.radius;
      quality = result.quality;
    }
    
    // Calculate angle from estimated center
    const dx = sample.smoothAccel.x - centerX;
    const dy = sample.smoothAccel.y - centerY;
    const currentAngle = Math.atan2(dy, dx);
    
    let angularVelocity = 0;
    if (this.lastAngle !== null) {
      let deltaAngle = currentAngle - this.lastAngle;
      
      // Handle angle wrapping
      if (deltaAngle > Math.PI) deltaAngle -= TAU;
      if (deltaAngle < -Math.PI) deltaAngle += TAU;
      
      angularVelocity = deltaAngle / dt;
      
      // Accumulate rotation if motion quality is good
      if (quality > 0.4 && Math.abs(angularVelocity) > 0.5) {
        this.totalRotation += Math.abs(deltaAngle);
        
        if (this.circleStartTime === 0) {
          this.circleStartTime = sample.time;
        }
      }
    }
    
    this.lastAngle = currentAngle;
    this.estimatedRadius = radius;
    
    // Calculate progress
    this.circleProgress = Math.min(1, this.totalRotation / TAU);
    
    // Check for complete circle
    if (this.circleProgress >= 0.95 && this.circleStartTime > 0) {
      const circleTime = (sample.time - this.circleStartTime) / 1000;
      
      if (circleTime >= this.minCircleTime && 
          circleTime <= this.maxCircleTime && 
          quality >= this.qualityThreshold &&
          radius >= this.minRadius && 
          radius <= this.maxRadius) {
        
        this._onCircleDetected(circleTime, radius, quality);
        this._resetDetection();
      }
    }
    
    // Reset if motion stops or becomes erratic
    if (sample.accelMag < 0.5 || quality < 0.2) {
      if (sample.time - this.circleStartTime > 2000) { // 2 second timeout
        this._resetDetection();
      }
    }
    
    // Update UI
    const centripetalAccel = radius > 0 ? (sample.velMag * sample.velMag) / radius : 0;
    this._updateHUD(centripetalAccel, angularVelocity * DEG, quality, sample.accelMag, radius);
    this._updateProgress();
  }
  
  _estimateCircleParams(samples) {
    if (samples.length < 3) return { centerX: 0, centerY: 0, radius: 0, quality: 0 };
    
    // Use acceleration data to estimate circular motion
    let sumX = 0, sumY = 0, sumX2 = 0, sumY2 = 0, sumXY = 0;
    let sumAx = 0, sumAy = 0;
    
    for (let i = 0; i < samples.length; i++) {
      const s = samples[i];
      const x = s.smoothAccel.x;
      const y = s.smoothAccel.y;
      
      sumX += x;
      sumY += y;
      sumX2 += x * x;
      sumY2 += y * y;
      sumXY += x * y;
      sumAx += Math.abs(s.smoothAccel.x);
      sumAy += Math.abs(s.smoothAccel.y);
    }
    
    const n = samples.length;
    const meanX = sumX / n;
    const meanY = sumY / n;
    
    // Calculate variance and correlation for quality assessment
    const varX = (sumX2 / n) - (meanX * meanX);
    const varY = (sumY2 / n) - (meanY * meanY);
    const correlation = Math.abs((sumXY / n) - (meanX * meanY)) / Math.sqrt(varX * varY + 1e-10);
    
    // Estimate radius from acceleration magnitude
    const avgAccelMag = Math.sqrt(sumAx * sumAx + sumAy * sumAy) / n;
    const avgVelMag = samples.reduce((sum, s) => sum + s.velMag, 0) / n;
    
    const radius = avgVelMag > 0.1 ? (avgVelMag * avgVelMag) / Math.max(avgAccelMag, 0.1) : 0;
    
    // Quality based on motion consistency and circularity
    const motionConsistency = Math.min(1, avgAccelMag / 3);
    const circularityScore = Math.min(1, correlation * 2);
    const quality = (motionConsistency + circularityScore) / 2;
    
    return {
      centerX: meanX,
      centerY: meanY,
      radius: Math.min(radius, 1.0), // Clamp to reasonable values
      quality: quality
    };
  }
  
  _updateVisualization(sample) {
    // Draw motion path
    const x = this.centerX + (sample.smoothAccel.x * 40);
    const y = this.centerY + (sample.smoothAccel.y * 40);
    
    this.ctx.strokeStyle = `hsl(${(this.circleProgress * 240)}, 70%, 60%)`;
    this.ctx.globalAlpha = 0.8;
    
    if (!this.pathStarted) {
      this.ctx.beginPath();
      this.ctx.moveTo(x, y);
      this.pathStarted = true;
    } else {
      this.ctx.lineTo(x, y);
      this.ctx.stroke();
    }
    
    // Update dot position
    this.dot.style.transform = `translate(${x - this.centerX}px, ${y - this.centerY}px)`;
    
    // Show circle indicator if detecting
    if (this.circleProgress > 0.1) {
      this.indicator.style.display = 'block';
    } else {
      this.indicator.style.display = 'none';
    }
  }
  
  _updateProgress() {
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const percent = Math.round(this.circleProgress * 100);
    
    if (progressBar) progressBar.style.width = `${percent}%`;
    if (progressText) progressText.textContent = `Circular motion: ${percent}%`;
  }
  
  _updateHUD(centripetal, angularVel, quality, energy, radius) {
    const elements = {
      'centripetal': centripetal.toFixed(2) + ' m/sÂ²',
      'angularVel': angularVel.toFixed(0) + ' Â°/s',
      'quality': Math.round(quality * 100) + '%',
      'energy': energy.toFixed(2),
      'radius': Math.round(radius * 100) + ' cm'
    };
    
    Object.entries(elements).forEach(([id, text]) => {
      const el = document.getElementById(id);
      if (el) el.textContent = text;
    });
  }
  
  _onCircleDetected(duration, radius, quality) {
    // Visual feedback
    document.body.style.background = 'linear-gradient(135deg,#4CAF50 0%,#45a049 100%)';
    setTimeout(() => {
      document.body.style.background = 'linear-gradient(135deg,#667eea 0%,#764ba2 100%)';
    }, 800);
    
    // Status update
    const status = document.getElementById('status');
    if (status) {
      status.textContent = 'ðŸŽ‰ Circular motion detected!';
      status.className = 'status detecting';
      setTimeout(() => {
        status.textContent = 'Ready! Move your arm in circles';
        status.className = 'status active';
      }, 1500);
    }
    
    // Add to history
    const history = document.getElementById('history');
    if (history) {
      const div = document.createElement('div');
      div.className = 'detection-item';
      div.textContent = `${new Date().toLocaleTimeString()}: Circle (${duration.toFixed(1)}s, r=${Math.round(radius*100)}cm, q=${Math.round(quality*100)}%)`;
      history.appendChild(div);
      history.scrollTop = history.scrollHeight;
    }
    
    // Haptic feedback
    if ('vibrate' in navigator) {
      navigator.vibrate([150, 100, 150]);
    }
  }
}

// Global state
let detector = null;
let isActive = false;

function startDetection() {
  if (isActive) return;
  
  const canvas = document.getElementById('pathCanvas');
  const dot = document.getElementById('motionDot');
  const indicator = document.getElementById('circleIndicator');
  
  detector = new CircularMotionDetector(canvas, dot, indicator);
  
  window.addEventListener('devicemotion', onMotionEvent, { passive: true });
  isActive = true;
  
  const status = document.getElementById('status');
  if (status) {
    status.textContent = 'Calibrating... hold still';
    status.className = 'status';
  }
  
  document.getElementById('startBtn').style.display = 'none';
  document.getElementById('stopBtn').style.display = 'inline-block';
  
  // Check for sensor availability
  let hasData = false;
  const checkSensors = () => { hasData = true; };
  window.addEventListener('devicemotion', checkSensors, { passive: true });
  
  setTimeout(() => {
    window.removeEventListener('devicemotion', checkSensors);
    if (!hasData) {
      document.getElementById('sensorNotice').style.display = 'block';
    }
  }, 2000);
}

function stopDetection() {
  if (!isActive) return;
  
  window.removeEventListener('devicemotion', onMotionEvent);
  isActive = false;
  
  const status = document.getElementById('status');
  if (status) {
    status.textContent = 'Detection stopped';
    status.className = 'status';
  }
  
  document.getElementById('startBtn').style.display = 'inline-block';
  document.getElementById('stopBtn').style.display = 'none';
  document.getElementById('circleIndicator').style.display = 'none';
}

function onMotionEvent(event) {
  if (detector) {
    detector.addMotionSample(
      event.acceleration,
      event.accelerationIncludingGravity,
      event.rotationRate,
      event.timeStamp || performance.now()
    );
  }
}

function clearHistory() {
  const history = document.getElementById('history');
  if (history) history.innerHTML = '';
  
  const progressBar = document.getElementById('progressBar');
  const progressText = document.getElementById('progressText');
  if (progressBar) progressBar.style.width = '0%';
  if (progressText) progressText.textContent = 'Circular motion: 0%';
  
  if (detector) detector._resetDetection();
}

// Handle window resize
window.addEventListener('resize', () => {
  if (detector) {
    detector._setupCanvas();
  }
});
</script>
</body>
</html>