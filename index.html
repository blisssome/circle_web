<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Enhanced Circular Motion Detector</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  body{
    font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;
    background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);
    min-height:100vh;display:flex;justify-content:center;align-items:center;color:#fff
  }
  .container{
    background:rgba(255,255,255,.1);backdrop-filter:blur(10px);
    border-radius:20px;padding:24px;width:min(420px,92vw);text-align:center;
    box-shadow:0 8px 32px rgba(0,0,0,.12);border:1px solid rgba(255,255,255,.2)
  }
  h1{font-size:22px;font-weight:700;margin-bottom:12px}
  .status{padding:12px;border-radius:10px;margin:12px 0;font-weight:600;border:1px solid rgba(255,255,255,.35)}
  .status.active{background:rgba(76,175,80,.18);border-color:rgba(76,175,80,.55)}
  .status.detecting{background:rgba(255,193,7,.2);border-color:rgba(255,193,7,.6);animation:pulse 1.5s infinite}
  @keyframes pulse{0%,100%{transform:scale(1)}50%{transform:scale(1.02)}}
  .visual{
    position:relative;width:280px;height:280px;margin:14px auto 10px;border-radius:50%;
    border:2px solid rgba(255,255,255,.28);background:rgba(255,255,255,.06);
    box-shadow:inset 0 0 0 2px rgba(255,255,255,.08);overflow:hidden
  }
  canvas#pathCanvas{width:100%;height:100%;display:block}
  #motionDot{
    position:absolute;width:12px;height:12px;border-radius:50%;
    background:#4CAF50;top:50%;left:50%;transform:translate(-50%,-50%);
    box-shadow:0 0 0 2px rgba(0,0,0,.12);transition:transform .08s ease
  }
  .progress-bar{width:100%;height:18px;background:rgba(255,255,255,.2);border-radius:10px;overflow:hidden;margin:8px 0}
  .progress-fill{height:100%;width:0%;background:linear-gradient(90deg,#4CAF50,#FFC107,#FF5722);border-radius:10px;transition:width .2s ease}
  .data-display{background:rgba(0,0,0,.22);border-radius:10px;padding:12px;margin-top:12px;
    font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,'Liberation Mono',monospace;font-size:12px;text-align:left}
  .data-row{display:flex;justify-content:space-between;margin:4px 0}
  .detection-history{max-height:160px;overflow-y:auto;background:rgba(0,0,0,.22);border-radius:10px;padding:10px;margin-top:12px;text-align:left}
  .detection-item{padding:4px 0;border-bottom:1px solid rgba(255,255,255,.12);font-size:13px}
  button{
    background:rgba(255,255,255,.18);border:1px solid rgba(255,255,255,.34);color:#fff;
    padding:10px 18px;border-radius:22px;cursor:pointer;font-size:15px;margin:8px 6px;transition:all .15s ease
  }
  button:hover{background:rgba(255,255,255,.28);transform:translateY(-1px)}
  button:active{transform:translateY(0)}
  #sensorNotice{display:none;margin-top:8px;padding:10px;border-radius:10px;background:rgba(255,107,107,.18);border:1px solid rgba(255,107,107,.5);font-size:13px;text-align:left}
  .circle-indicator{
    position:absolute;
    top:10px;
    left:10px;
    width:20px;
    height:20px;
    border:2px solid rgba(255,255,255,.4);
    border-radius:50%;
    border-top:2px solid #4CAF50;
    display:none;
    animation:spin 1s linear infinite;
  }
  @keyframes spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
</style>
</head>
<body>
  <div class="container">
    <h1>ðŸ”„ Enhanced Circular Motion Detector</h1>

    <div id="status" class="status">Hold phone steady, move your arm in circles</div>

    <div class="visual">
      <canvas id="pathCanvas"></canvas>
      <div id="motionDot"></div>
      <div id="circleIndicator" class="circle-indicator"></div>
    </div>

    <div class="progress-bar"><div id="progressBar" class="progress-fill"></div></div>
    <div id="progressText">Circular motion: 0%</div>

    <div>
      <button id="startBtn" onclick="startDetection()">Start Detection</button>
      <button id="stopBtn" onclick="stopDetection()" style="display:none;">Stop</button>
      <button onclick="clearHistory()">Clear History</button>
    </div>

    <div class="data-display">
      <div class="data-row"><span>Centripetal Accel:</span> <span id="centripetal">0.00 m/sÂ²</span></div>
      <div class="data-row"><span>Angular Velocity:</span> <span id="angularVel">0 Â°/s</span></div>
      <div class="data-row"><span>Circle Quality:</span> <span id="quality">0%</span></div>
      <div class="data-row"><span>Motion Energy:</span> <span id="energy">0.00</span></div>
      <div class="data-row"><span>Radius Est:</span> <span id="radius">0 cm</span></div>
    </div>

    <div class="detection-history">
      <strong>Detection History:</strong>
      <div id="history"></div>
    </div>

    <div id="sensorNotice">
      <strong>No motion data received.</strong><br>
      iPhone/iPad: Safari â†’ "aA" â†’ Website Settings â†’ Motion & Orientation Access â†’ ON, then reload.<br>
      Android Chrome: lock icon â†’ Site settings â†’ Motion sensors â†’ Allow.
    </div>
  </div>

<script>
const TAU = Math.PI * 2;
const DEG = 180 / Math.PI;

class CircularMotionDetector {
  constructor(canvas, dot, indicator) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.dot = dot;
    this.indicator = indicator;
    
    // Detection parameters - made much stricter
    this.minCircleTime = 0.8;      // Minimum time for one circle (seconds) - slower
    this.maxCircleTime = 4.0;      // Maximum time for one circle - allow slower circles  
    this.minRadius = 0.12;         // Minimum radius in meters - larger minimum
    this.maxRadius = 0.6;          // Maximum radius in meters
    this.qualityThreshold = 0.75;  // Higher minimum circle quality (0-1)
    this.minCentripetalAccel = 1.5; // Higher minimum centripetal acceleration
    
    // State variables
    this.isCalibrating = true;
    this.calibrationStart = 0;
    this.gravity = null;
    this.lastTime = 0;
    this.motionHistory = [];
    this.maxHistoryLength = 150; // ~3 seconds at 50Hz
    
    // Circular motion tracking
    this.circleProgress = 0;
    this.currentAngle = 0;
    this.lastAngle = null;
    this.totalRotation = 0;
    this.circleStartTime = 0;
    this.centerX = 0;
    this.centerY = 0;
    this.estimatedRadius = 0;
    
    // Smoothing
    this.smoothedAccel = { x: 0, y: 0 };
    this.smoothedVel = { x: 0, y: 0 };
    this.smoothingFactor = 0.1;
    
    this._setupCanvas();
    this._resetDetection();
  }
  
  _setupCanvas() {
    const rect = this.canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    
    this.canvas.width = rect.width * dpr;
    this.canvas.height = rect.height * dpr;
    this.ctx.scale(dpr, dpr);
    
    this.canvasWidth = rect.width;
    this.canvasHeight = rect.height;
    this.centerX = this.canvasWidth / 2;
    this.centerY = this.canvasHeight / 2;
    this.maxRadius = Math.min(this.canvasWidth, this.canvasHeight) * 0.4;
    
    this.ctx.lineWidth = 2;
    this.ctx.lineCap = 'round';
    this._clearCanvas();
  }
  
  _clearCanvas() {
    this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
    
    // Draw reference circle
    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
    this.ctx.beginPath();
    this.ctx.arc(this.centerX, this.centerY, this.maxRadius * 0.8, 0, TAU);
    this.ctx.stroke();
    
    // Reset path
    this.pathStarted = false;
  }
  
  _resetDetection() {
    this.circleProgress = 0;
    this.totalRotation = 0;
    this.lastAngle = null;
    this.circleStartTime = 0;
    this.motionHistory = [];
    this.estimatedRadius = 0;
    this._updateProgress();
    this._clearCanvas();
  }
  
  addMotionSample(acceleration, accelerationGravity, rotationRate, timestamp) {
    const now = timestamp || performance.now();
    const dt = this.lastTime ? (now - this.lastTime) / 1000 : 1/60;
    this.lastTime = now;
    
    // Establish gravity vector
    if (!this.gravity && accelerationGravity) {
      this.gravity = {
        x: accelerationGravity.x,
        y: accelerationGravity.y,
        z: accelerationGravity.z
      };
      return;
    }
    
    if (!this.gravity) return;
    
    // Update gravity estimate with low-pass filter
    if (accelerationGravity) {
      const alpha = 0.02;
      this.gravity.x = (1 - alpha) * this.gravity.x + alpha * accelerationGravity.x;
      this.gravity.y = (1 - alpha) * this.gravity.y + alpha * accelerationGravity.y;
      this.gravity.z = (1 - alpha) * this.gravity.z + alpha * accelerationGravity.z;
    }
    
    // Calculate linear acceleration (remove gravity)
    let linearAccel = { x: 0, y: 0, z: 0 };
    if (acceleration) {
      linearAccel = acceleration;
    } else if (accelerationGravity) {
      linearAccel = {
        x: accelerationGravity.x - this.gravity.x,
        y: accelerationGravity.y - this.gravity.y,
        z: accelerationGravity.z - this.gravity.z
      };
    }
    
    // Smooth the acceleration
    this.smoothedAccel.x = (1 - this.smoothingFactor) * this.smoothedAccel.x + this.smoothingFactor * linearAccel.x;
    this.smoothedAccel.y = (1 - this.smoothingFactor) * this.smoothedAccel.y + this.smoothingFactor * linearAccel.y;
    
    // Estimate velocity by integration (with decay to prevent drift)
    const velocityDecay = 0.95;
    this.smoothedVel.x = this.smoothedVel.x * velocityDecay + this.smoothedAccel.x * dt;
    this.smoothedVel.y = this.smoothedVel.y * velocityDecay + this.smoothedAccel.y * dt;
    
    // Calculate motion metrics
    const accelMagnitude = Math.sqrt(linearAccel.x**2 + linearAccel.y**2 + linearAccel.z**2);
    const planarAccelMag = Math.sqrt(this.smoothedAccel.x**2 + this.smoothedAccel.y**2);
    const velMagnitude = Math.sqrt(this.smoothedVel.x**2 + this.smoothedVel.y**2);
    
    // Store motion history
    const motionSample = {
      time: now,
      accel: { x: linearAccel.x, y: linearAccel.y },
      smoothAccel: { x: this.smoothedAccel.x, y: this.smoothedAccel.y },
      velocity: { x: this.smoothedVel.x, y: this.smoothedVel.y },
      accelMag: planarAccelMag,
      velMag: velMagnitude
    };
    
    this.motionHistory.push(motionSample);
    if (this.motionHistory.length > this.maxHistoryLength) {
      this.motionHistory.shift();
    }
    
    // Calibration phase
    if (this.isCalibrating) {
      if (this.calibrationStart === 0) {
        this.calibrationStart = now;
      }
      
      if (now - this.calibrationStart > 1000) { // 1 second calibration
        this.isCalibrating = false;
        const status = document.getElementById('status');
        if (status) {
          status.textContent = 'Ready! Move your arm in circles';
          status.className = 'status active';
        }
      }
      this._updateHUD(planarAccelMag, 0, 0, 0, 0);
      return;
    }
    
    // Detect circular motion
    this._detectCircularMotion(motionSample, dt);
    
    // Update visualization
    this._updateVisualization(motionSample);
  }
  
  _detectCircularMotion(sample, dt) {
    if (this.motionHistory.length < 30) return; // Need more samples for reliable detection
    
    // Use longer window for better circle detection
    const windowSize = Math.min(60, this.motionHistory.length); // ~1.2 seconds at 50Hz
    const recent = this.motionHistory.slice(-windowSize);
    
    // Perform comprehensive circular motion analysis
    const circleAnalysis = this._analyzeCircularMotion(recent);
    
    if (!circleAnalysis.isCircular) {
      // Reset if not detecting circular motion
      if (this.circleStartTime > 0 && sample.time - this.circleStartTime > 1000) {
        this._resetDetection();
      }
      this._updateHUD(0, 0, 0, sample.accelMag, 0);
      return;
    }
    
    // Track angular position more carefully
    const angle = Math.atan2(sample.smoothAccel.y - circleAnalysis.centerY, 
                             sample.smoothAccel.x - circleAnalysis.centerX);
    
    let angularVelocity = 0;
    if (this.lastAngle !== null) {
      let deltaAngle = angle - this.lastAngle;
      
      // Handle angle wrapping
      if (deltaAngle > Math.PI) deltaAngle -= TAU;
      if (deltaAngle < -Math.PI) deltaAngle += TAU;
      
      angularVelocity = deltaAngle / dt;
      
      // Only accumulate if we have consistent circular motion
      if (circleAnalysis.quality > 0.7 && 
          Math.abs(angularVelocity) > 0.8 && 
          Math.abs(angularVelocity) < 8.0 && // Reasonable angular velocity range
          circleAnalysis.consistency > 0.6) {
        
        // Start new circle if not already tracking
        if (this.circleStartTime === 0) {
          this.circleStartTime = sample.time;
          this.totalRotation = 0;
        }
        
        // Accumulate rotation in consistent direction
        this.totalRotation += Math.abs(deltaAngle);
      }
    }
    
    this.lastAngle = angle;
    this.estimatedRadius = circleAnalysis.radius;
    
    // Calculate progress
    this.circleProgress = Math.min(1, this.totalRotation / TAU);
    
    // Check for complete circle with strict validation
    if (this.circleProgress >= 0.9 && this.circleStartTime > 0) {
      const circleTime = (sample.time - this.circleStartTime) / 1000;
      
      if (this._validateCompleteCircle(circleTime, circleAnalysis)) {
        this._onCircleDetected(circleTime, circleAnalysis.radius, circleAnalysis.quality);
        this._resetDetection();
      }
    }
    
    // Update UI
    const centripetalAccel = circleAnalysis.radius > 0 ? 
      (sample.velMag * sample.velMag) / circleAnalysis.radius : 0;
    this._updateHUD(centripetalAccel, angularVelocity * DEG, circleAnalysis.quality, 
                   sample.accelMag, circleAnalysis.radius);
    this._updateProgress();
  }
  
  _analyzeCircularMotion(samples) {
    if (samples.length < 30) {
      return { isCircular: false, quality: 0, radius: 0, centerX: 0, centerY: 0, consistency: 0 };
    }
    
    // Extract acceleration vectors
    const positions = samples.map(s => ({ x: s.smoothAccel.x, y: s.smoothAccel.y }));
    
    // 1. Test for circular shape using multiple methods
    const circularityTests = this._testCircularity(positions);
    
    // 2. Check for consistent rotation direction
    const rotationConsistency = this._checkRotationConsistency(positions);
    
    // 3. Verify periodic motion pattern
    const periodicityScore = this._checkPeriodicity(samples);
    
    // 4. Estimate circle parameters
    const circleParams = this._fitCircle(positions);
    
    // 5. Validate against shaking patterns
    const antiShakeScore = this._detectShaking(samples);
    
    // Combine all tests
    const overallQuality = (
      circularityTests.shape * 0.25 +
      rotationConsistency * 0.25 +
      periodicityScore * 0.2 +
      circleParams.quality * 0.2 +
      antiShakeScore * 0.1
    );
    
    const isCircular = (
      overallQuality > 0.65 &&
      circularityTests.shape > 0.6 &&
      rotationConsistency > 0.5 &&
      antiShakeScore > 0.7 &&
      circleParams.radius > 0.08 &&
      circleParams.radius < 0.8
    );
    
    return {
      isCircular: isCircular,
      quality: overallQuality,
      radius: circleParams.radius,
      centerX: circleParams.centerX,
      centerY: circleParams.centerY,
      consistency: rotationConsistency
    };
  }
  
  _testCircularity(positions) {
    if (positions.length < 10) return { shape: 0 };
    
    // Find approximate center
    let sumX = 0, sumY = 0;
    positions.forEach(p => { sumX += p.x; sumY += p.y; });
    const centerX = sumX / positions.length;
    const centerY = sumY / positions.length;
    
    // Calculate distances from center
    const distances = positions.map(p => 
      Math.sqrt((p.x - centerX)**2 + (p.y - centerY)**2)
    );
    
    // Check if distances are reasonably consistent (circular shape)
    const avgDist = distances.reduce((a, b) => a + b, 0) / distances.length;
    const distVariance = distances.reduce((sum, d) => sum + (d - avgDist)**2, 0) / distances.length;
    const distStdDev = Math.sqrt(distVariance);
    
    // Circular shape score (lower variance = more circular)
    const shapeScore = avgDist > 0.05 ? Math.max(0, 1 - (distStdDev / avgDist) * 3) : 0;
    
    return { shape: shapeScore };
  }
  
  _checkRotationConsistency(positions) {
    if (positions.length < 20) return 0;
    
    // Calculate angles for each position relative to center
    let sumX = 0, sumY = 0;
    positions.forEach(p => { sumX += p.x; sumY += p.y; });
    const centerX = sumX / positions.length;
    const centerY = sumY / positions.length;
    
    const angles = positions.map(p => 
      Math.atan2(p.y - centerY, p.x - centerX)
    );
    
    // Check for consistent rotation direction
    let positiveRotations = 0;
    let negativeRotations = 0;
    let totalRotation = 0;
    
    for (let i = 1; i < angles.length; i++) {
      let deltaAngle = angles[i] - angles[i-1];
      
      // Handle wrapping
      if (deltaAngle > Math.PI) deltaAngle -= TAU;
      if (deltaAngle < -Math.PI) deltaAngle += TAU;
      
      if (Math.abs(deltaAngle) > 0.05) { // Filter out noise
        if (deltaAngle > 0) positiveRotations++;
        else negativeRotations++;
        totalRotation += Math.abs(deltaAngle);
      }
    }
    
    const totalChanges = positiveRotations + negativeRotations;
    if (totalChanges < 5) return 0;
    
    // Consistency = how much we favor one direction
    const directionConsistency = Math.abs(positiveRotations - negativeRotations) / totalChanges;
    
    // Also check if we have reasonable total rotation
    const rotationAmount = Math.min(1, totalRotation / (Math.PI * 0.5)); // At least quarter circle
    
    return directionConsistency * rotationAmount;
  }
  
  _checkPeriodicity(samples) {
    if (samples.length < 40) return 0;
    
    // Look for periodic patterns in acceleration magnitude
    const accelMags = samples.map(s => s.accelMag);
    
    // Simple autocorrelation for periodicity detection
    let bestCorrelation = 0;
    const minPeriod = 8;  // Min samples for a period
    const maxPeriod = Math.floor(samples.length / 3);
    
    for (let period = minPeriod; period <= maxPeriod; period++) {
      let correlation = 0;
      let count = 0;
      
      for (let i = 0; i < accelMags.length - period; i++) {
        correlation += accelMags[i] * accelMags[i + period];
        count++;
      }
      
      if (count > 0) {
        correlation /= count;
        bestCorrelation = Math.max(bestCorrelation, correlation);
      }
    }
    
    // Normalize correlation
    const avgMagSquared = accelMags.reduce((sum, mag) => sum + mag * mag, 0) / accelMags.length;
    const periodicityScore = avgMagSquared > 0 ? Math.min(1, bestCorrelation / avgMagSquared) : 0;
    
    return Math.max(0, periodicityScore);
  }
  
  _fitCircle(positions) {
    if (positions.length < 3) {
      return { centerX: 0, centerY: 0, radius: 0, quality: 0 };
    }
    
    // Simple centroid-based circle fitting
    let sumX = 0, sumY = 0;
    positions.forEach(p => { sumX += p.x; sumY += p.y; });
    const centerX = sumX / positions.length;
    const centerY = sumY / positions.length;
    
    // Calculate average radius
    const distances = positions.map(p => 
      Math.sqrt((p.x - centerX)**2 + (p.y - centerY)**2)
    );
    const avgRadius = distances.reduce((a, b) => a + b, 0) / distances.length;
    
    // Quality based on how well points fit the circle
    const radiusVariance = distances.reduce((sum, d) => sum + (d - avgRadius)**2, 0) / distances.length;
    const quality = avgRadius > 0.02 ? Math.max(0, 1 - Math.sqrt(radiusVariance) / avgRadius) : 0;
    
    return {
      centerX: centerX,
      centerY: centerY,
      radius: avgRadius,
      quality: quality
    };
  }
  
  _detectShaking(samples) {
    if (samples.length < 20) return 1;
    
    // Shaking typically has:
    // 1. High frequency changes in direction
    // 2. No consistent circular pattern
    // 3. Back-and-forth motion rather than continuous rotation
    
    let directionChanges = 0;
    let backAndForthMotion = 0;
    
    for (let i = 2; i < samples.length; i++) {
      const curr = samples[i].smoothAccel;
      const prev = samples[i-1].smoothAccel;
      const prev2 = samples[i-2].smoothAccel;
      
      // Check for direction reversals (shaking indicator)
      const vel1 = { x: prev.x - prev2.x, y: prev.y - prev2.y };
      const vel2 = { x: curr.x - prev.x, y: curr.y - prev.y };
      const dotProduct = vel1.x * vel2.x + vel1.y * vel2.y;
      
      if (dotProduct < -0.1) { // Opposite directions
        directionChanges++;
      }
      
      // Check for back-and-forth vs circular motion
      const dist1 = Math.sqrt(vel1.x**2 + vel1.y**2);
      const dist2 = Math.sqrt(vel2.x**2 + vel2.y**2);
      
      if (dist1 > 0.1 && dist2 > 0.1 && dotProduct < 0) {
        backAndForthMotion++;
      }
    }
    
    const totalSamples = samples.length - 2;
    const shakeRatio = directionChanges / totalSamples;
    const backForthRatio = backAndForthMotion / totalSamples;
    
    // Higher shake indicators = lower anti-shake score
    const antiShakeScore = Math.max(0, 1 - shakeRatio * 2 - backForthRatio * 1.5);
    
    return antiShakeScore;
  }
  
  _validateCompleteCircle(duration, analysis) {
    return (
      duration >= this.minCircleTime &&
      duration <= this.maxCircleTime &&
      analysis.quality >= 0.7 &&
      analysis.consistency >= 0.6 &&
      analysis.radius >= this.minRadius &&
      analysis.radius <= this.maxRadius
    );
  }
  
  _updateVisualization(sample) {
    // Draw motion path
    const x = this.centerX + (sample.smoothAccel.x * 40);
    const y = this.centerY + (sample.smoothAccel.y * 40);
    
    this.ctx.strokeStyle = `hsl(${(this.circleProgress * 240)}, 70%, 60%)`;
    this.ctx.globalAlpha = 0.8;
    
    if (!this.pathStarted) {
      this.ctx.beginPath();
      this.ctx.moveTo(x, y);
      this.pathStarted = true;
    } else {
      this.ctx.lineTo(x, y);
      this.ctx.stroke();
    }
    
    // Update dot position
    this.dot.style.transform = `translate(${x - this.centerX}px, ${y - this.centerY}px)`;
    
    // Show circle indicator if detecting
    if (this.circleProgress > 0.1) {
      this.indicator.style.display = 'block';
    } else {
      this.indicator.style.display = 'none';
    }
  }
  
  _updateProgress() {
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    const percent = Math.round(this.circleProgress * 100);
    
    if (progressBar) progressBar.style.width = `${percent}%`;
    if (progressText) progressText.textContent = `Circular motion: ${percent}%`;
  }
  
  _updateHUD(centripetal, angularVel, quality, energy, radius) {
    const elements = {
      'centripetal': centripetal.toFixed(2) + ' m/sÂ²',
      'angularVel': angularVel.toFixed(0) + ' Â°/s',
      'quality': Math.round(quality * 100) + '%',
      'energy': energy.toFixed(2),
      'radius': Math.round(radius * 100) + ' cm'
    };
    
    Object.entries(elements).forEach(([id, text]) => {
      const el = document.getElementById(id);
      if (el) el.textContent = text;
    });
  }
  
  _onCircleDetected(duration, radius, quality) {
    // Visual feedback
    document.body.style.background = 'linear-gradient(135deg,#4CAF50 0%,#45a049 100%)';
    setTimeout(() => {
      document.body.style.background = 'linear-gradient(135deg,#667eea 0%,#764ba2 100%)';
    }, 800);
    
    // Status update
    const status = document.getElementById('status');
    if (status) {
      status.textContent = 'ðŸŽ‰ Circular motion detected!';
      status.className = 'status detecting';
      setTimeout(() => {
        status.textContent = 'Ready! Move your arm in circles';
        status.className = 'status active';
      }, 1500);
    }
    
    // Add to history
    const history = document.getElementById('history');
    if (history) {
      const div = document.createElement('div');
      div.className = 'detection-item';
      div.textContent = `${new Date().toLocaleTimeString()}: Circle (${duration.toFixed(1)}s, r=${Math.round(radius*100)}cm, q=${Math.round(quality*100)}%)`;
      history.appendChild(div);
      history.scrollTop = history.scrollHeight;
    }
    
    // Haptic feedback
    if ('vibrate' in navigator) {
      navigator.vibrate([150, 100, 150]);
    }
  }
}

// Global state
let detector = null;
let isActive = false;

function startDetection() {
  if (isActive) return;
  
  const canvas = document.getElementById('pathCanvas');
  const dot = document.getElementById('motionDot');
  const indicator = document.getElementById('circleIndicator');
  
  detector = new CircularMotionDetector(canvas, dot, indicator);
  
  window.addEventListener('devicemotion', onMotionEvent, { passive: true });
  isActive = true;
  
  const status = document.getElementById('status');
  if (status) {
    status.textContent = 'Calibrating... hold still';
    status.className = 'status';
  }
  
  document.getElementById('startBtn').style.display = 'none';
  document.getElementById('stopBtn').style.display = 'inline-block';
  
  // Check for sensor availability
  let hasData = false;
  const checkSensors = () => { hasData = true; };
  window.addEventListener('devicemotion', checkSensors, { passive: true });
  
  setTimeout(() => {
    window.removeEventListener('devicemotion', checkSensors);
    if (!hasData) {
      document.getElementById('sensorNotice').style.display = 'block';
    }
  }, 2000);
}

function stopDetection() {
  if (!isActive) return;
  
  window.removeEventListener('devicemotion', onMotionEvent);
  isActive = false;
  
  const status = document.getElementById('status');
  if (status) {
    status.textContent = 'Detection stopped';
    status.className = 'status';
  }
  
  document.getElementById('startBtn').style.display = 'inline-block';
  document.getElementById('stopBtn').style.display = 'none';
  document.getElementById('circleIndicator').style.display = 'none';
}

function onMotionEvent(event) {
  if (detector) {
    detector.addMotionSample(
      event.acceleration,
      event.accelerationIncludingGravity,
      event.rotationRate,
      event.timeStamp || performance.now()
    );
  }
}

function clearHistory() {
  const history = document.getElementById('history');
  if (history) history.innerHTML = '';
  
  const progressBar = document.getElementById('progressBar');
  const progressText = document.getElementById('progressText');
  if (progressBar) progressBar.style.width = '0%';
  if (progressText) progressText.textContent = 'Circular motion: 0%';
  
  if (detector) detector._resetDetection();
}

// Handle window resize
window.addEventListener('resize', () => {
  if (detector) {
    detector._setupCanvas();
  }
});
</script>
</body>
</html>