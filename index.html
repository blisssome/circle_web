<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Wrist/Elbow Revolution ‚Äî Angle Accumulator (No Prompts)</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh; display: flex; justify-content: center; align-items: center; color: #fff;
    }
    .container {
      background: rgba(255,255,255,0.1); backdrop-filter: blur(10px);
      border-radius: 20px; padding: 24px; width: min(420px, 92vw);
      text-align: center; box-shadow: 0 8px 32px rgba(0,0,0,0.12);
      border: 1px solid rgba(255,255,255,0.2);
    }
    h1 { font-size: 22px; font-weight: 700; margin-bottom: 12px; }
    .status { padding: 12px; border-radius: 10px; margin: 12px 0; font-weight: 600; border: 1px solid rgba(255,255,255,0.35); }
    .status.active { background: rgba(76,175,80,0.18); border-color: rgba(76,175,80,0.55); }
    .status.detecting { background: rgba(255,193,7,0.2); border-color: rgba(255,193,7,0.6); animation: pulse 1.5s infinite; }
    @keyframes pulse { 0%,100%{transform:scale(1)} 50%{transform:scale(1.02)} }

    .visual {
      position: relative; width: 280px; height: 280px; margin: 14px auto 10px;
      border-radius: 50%; border: 2px solid rgba(255,255,255,0.28);
      background: rgba(255,255,255,0.06);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,0.08);
      overflow: hidden;
    }
    canvas#pathCanvas { width: 100%; height: 100%; display: block; }
    #gyroDot {
      position: absolute; width: 10px; height: 10px; border-radius: 50%;
      background: #4CAF50; top: 50%; left: 50%; transform: translate(-50%,-50%);
      box-shadow: 0 0 0 2px rgba(0,0,0,0.12);
      transition: transform 0.06s linear;
    }

    .confidence-bar { width: 100%; height: 18px; background: rgba(255,255,255,0.2);
      border-radius: 10px; overflow: hidden; margin: 8px 0; }
    .confidence-fill { height: 100%; width: 0%; background: linear-gradient(90deg,#4CAF50,#FFC107,#FF5722);
      border-radius: 10px; transition: width .2s ease; }

    .data-display { background: rgba(0,0,0,0.22); border-radius: 10px; padding: 10px; margin-top: 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 12px; text-align: left; }
    .detection-history { max-height: 160px; overflow-y: auto; background: rgba(0,0,0,0.22); border-radius: 10px; padding: 10px; margin-top: 12px; text-align: left; }
    .detection-item { padding: 4px 0; border-bottom: 1px solid rgba(255,255,255,0.12); font-size: 13px; }

    button {
      background: rgba(255,255,255,0.18); border: 1px solid rgba(255,255,255,0.34); color: #fff;
      padding: 10px 18px; border-radius: 22px; cursor: pointer; font-size: 15px; margin: 8px 6px;
      transition: all .15s ease;
    }
    button:hover { background: rgba(255,255,255,0.28); transform: translateY(-1px); }
    button:active { transform: translateY(0); }

    #sensorNotice{
      display: none; margin-top: 8px; padding: 10px; border-radius: 10px;
      background: rgba(255, 107, 107, 0.18); border: 1px solid rgba(255, 107, 107, 0.5);
      font-size: 13px; text-align: left;
    }
    #debugInfo { display:none; margin-top: 6px; font: 12px ui-monospace, monospace; opacity: .9; text-align: left; white-space: pre-wrap; }
  </style>
</head>
<body>
  <div class="container">
    <h1>üîÑ Wrist/Elbow Revolution ‚Äî Angle Accumulator</h1>

    <div id="status" class="status">Tap ‚ÄúStart‚Äù, hold still 1s, then draw a smooth circle</div>

    <div class="visual">
      <canvas id="pathCanvas"></canvas>
      <div id="gyroDot"></div>
    </div>

    <div class="confidence-bar"><div id="confidenceBar" class="confidence-fill"></div></div>
    <div id="confidenceText">Revolution progress: 0%</div>

    <div>
      <button id="startBtn" onclick="startDetection()">Start</button>
      <button id="stopBtn" onclick="stopDetection()" style="display:none;">Stop</button>
      <button onclick="clearHistory()">Clear History</button>
    </div>

    <div class="data-display">
      <div>|a‚üÇg| (m/s¬≤): <span id="planarA">0.00</span></div>
      <div>|v| (a-integrated): <span id="planarV">0.00</span></div>
      <div>œâ (deg/s): <span id="omega">0</span></div>
      <div>Coherence: <span id="coh">0.00</span></div>
    </div>

    <div class="detection-history">
      <strong>Detection History:</strong>
      <div id="history"></div>
    </div>

    <div id="sensorNotice">
      <strong>No motion data received.</strong><br>
      If you‚Äôre on iPhone/iPad: Safari ‚Üí tap ‚ÄúaA‚Äù ‚Üí Website Settings ‚Üí <em>Motion &amp; Orientation Access</em> ‚Üí ON, then reload.<br>
      On Android (Chrome): lock icon ‚Üí Site settings ‚Üí <em>Motion sensors</em> ‚Üí Allow.
    </div>

    <div id="debugInfo"></div>
  </div>

  <script>
    // Turn on to see gating details
    const DEBUG = false;

    // ---- Math helpers ----
    const TAU = Math.PI * 2;
    const DEG = Math.PI / 180;
    const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
    const unwrap = d => (d > Math.PI ? d - TAU : d < -Math.PI ? d + TAU : d);
    const hypot3 = (x,y,z)=>Math.sqrt(x*x + y*y + z*z);
    function cross(a,b){ return {x:a.y*b.z - a.z*b.y, y:a.z*b.x - a.x*b.z, z:a.x*b.y - a.y*b.x}; }
    function norm(v){ const n=hypot3(v.x,v.y,v.z)||1; return {x:v.x/n,y:v.y/n,z:v.z/n}; }
    function median(arr){ if(!arr.length) return 0; const s=[...arr].sort((a,b)=>a-b); const m=Math.floor(s.length/2); return s.length%2?s[m]:(s[m-1]+s[m])/2; }
    function mad(arr, m=null){ if(!arr.length) return 0; if(m==null) m=median(arr); const dev=arr.map(x=>Math.abs(x-m)); return median(dev); }

    class AngleAccumulatorDetector {
      constructor(canvas, dotEl){
        // ---- Tunables (made forgiving) ----
        this.progressTarget = TAU * 0.85;   // ~306¬∞ counts as a revolution
        this.segMinDur = 0.20;              // allow fast loops
        this.segMaxDur = 12.0;
        this.gapMsAllow = 350;

        // smoothing & integration
        this.betaMs = 0.08;                 // accel smoothing ~80ms
        this.gTau   = 0.25;                 // gravity LPF
        this.velTauActive = 1.20;           // leak while moving
        this.velTauQuiet  = 0.35;           // stronger leak when quiet
        this.posTau       = 12.0;           // very light leak

        // thresholds (will be calibrated, but we clamp to be gentle)
        this.aFloor = 0.05;                 // m/s¬≤
        this.vFloor = 0.05;                 // arbitrary velocity units
        this.omegaMin = 0.30;               // rad/s (~17¬∞/s) minimum angular speed
        this.omegaOff = 0.20;               // hysteresis

        // directional coherence (EWMA over ~1s)
        this.cohTau = 1.0;                  // seconds
        this.cohMin = 0.55;                 // must mostly go one way

        // anti spin-in-place (works only if rotationRate provided)
        this.yawSpinVeto      = 160;        // deg/s about gravity
        this.spinLinearThresh = 0.8;        // m/s¬≤

        // ---- State ----
        this.canvas=canvas; this.ctx=canvas.getContext('2d'); this.dotEl=dotEl;
        this.dpr=Math.max(1,window.devicePixelRatio||1);
        this.uiAlpha=0.25; this._uiX=0; this._uiY=0;

        this.g=null; this.lastT=0;
        this.uLP=0; this.vLP=0;
        this.uVel=0; this.vVel=0;
        this.uPos=0; this.vPos=0;

        this.prevTheta=null;
        this.thetaAbsAccum=0;               // sum of |ŒîŒ∏| for progress
        this.progress=0;
        this.segStartT=null; this.lastGoodMs=0;

        this.posEW=0; this.negEW=0;         // coherence trackers

        this.lastDetectMs=0; this.cooldownMs=1200;

        this.debugEl=document.getElementById('debugInfo'); if (DEBUG) this.debugEl.style.display='block';

        // canvas prep
        window.addEventListener('resize',()=>{this.resize();this.resetCanvas();},{passive:true});
        this.resize(); this.resetCanvas();

        // 1s calibration
        this.calibrating=true; this.calibStart=0; this.calibA=[]; this.calibW=[];
        this._startCalibration();
      }

      // ---- Layout ----
      resize(){
        const cw=this.canvas.clientWidth, ch=this.canvas.clientHeight;
        this.canvas.width=Math.floor(cw*this.dpr);
        this.canvas.height=Math.floor(ch*this.dpr);
        this.w=this.canvas.width; this.h=this.canvas.height;
        this.cx=this.w/2; this.cy=this.h/2;
        this.padPx=6*this.dpr;
        this.R = Math.min(this.cx,this.cy)-this.padPx;
        this.rDraw = this.R*0.65;

        this.ctx.setTransform(1,0,0,1,0,0);
        this.ctx.lineWidth=2*this.dpr; this.ctx.lineCap='round'; this.ctx.lineJoin='round';
        this.ctx.strokeStyle='rgba(255,255,255,0.95)';
      }
      resetCanvas(){
        this.ctx.clearRect(0,0,this.w,this.h);
        this.ctx.save(); this.ctx.globalAlpha=.18;
        this.ctx.beginPath(); this.ctx.arc(this.cx,this.cy,this.R,0,TAU); this.ctx.stroke(); this.ctx.restore();
        this.ctx.save(); this.ctx.beginPath();
        this.ctx.arc(this.cx,this.cy,this.R - this.ctx.lineWidth*0.5, 0, TAU); this.ctx.clip();
        this.pathStarted=false;

        this.uLP=this.vLP=0; this.uVel=this.vVel=0; this.uPos=this.vPos=0;
        this.prevTheta=null; this.thetaAbsAccum=0; this.progress=0;
        this.segStartT=null; this.lastGoodMs=0;
        this.posEW=0; this.negEW=0;
        this._lastXPix=this.cx; this._lastYPix=this.cy;
        this._renderProgress(); this._moveDot();
      }

      // ---- Calibration ----
      _startCalibration(){
        this.calibrating=true; this.calibA.length=0; this.calibW.length=0; this.calibStart=performance.now();
        const st=document.getElementById('status'); if (st){ st.textContent='Calibrating‚Ä¶ hold still for 1s'; st.className='status'; }
      }
      _finishCalibration(){
        const aMed=median(this.calibA), aMAD=mad(this.calibA,aMed)*1.4826;
        const wMed=median(this.calibW), wMAD=mad(this.calibW,wMed)*1.4826;
        // friendly floors with clamps so it can't become too strict
        this.aFloor   = Math.min(0.12, Math.max(0.03, aMed + 6*aMAD));
        this.vFloor   = 0.04; // keep lenient; we only need "moving vs still"
        this.omegaMin = Math.min(0.80, Math.max(0.20, wMed + 4*wMAD));
        this.omegaOff = Math.min(0.60, Math.max(0.15, wMed + 3*wMAD));
        this.calibrating=false;
        const st=document.getElementById('status'); if (st){ st.textContent='Listening‚Ä¶ draw a smooth wrist/elbow circle'; st.className='status active'; }
      }

      // ---- Main pipeline ----
      addSample(acc, accG, rr){
        const now=performance.now();
        const dt=this.lastT ? Math.max(0.001,(now-this.lastT)/1000) : 0.016;
        this.lastT=now;

        // gravity
        if (!this.g){
          if (accG && Number.isFinite(accG.x)) this.g={x:accG.x,y:accG.y,z:accG.z};
          else if (acc && Number.isFinite(acc.x)){ const mag=hypot3(acc.x,acc.y,acc.z); if (mag>7.5) this.g={x:acc.x,y:acc.y,z:acc.z}; else return; }
          else return;
        } else {
          const a=Math.exp(-dt/this.gTau);
          if (accG && Number.isFinite(accG.x)){
            this.g.x=a*this.g.x+(1-a)*accG.x; this.g.y=a*this.g.y+(1-a)*accG.y; this.g.z=a*this.g.z+(1-a)*accG.z;
          }
        }

        // linear accel in plane ‚üÇ g
        let ax=0,ay=0,az=0;
        if (acc && Number.isFinite(acc.x)){ ax=acc.x; ay=acc.y; az=acc.z; }
        else if (accG){ ax=accG.x-this.g.x; ay=accG.y-this.g.y; az=accG.z-this.g.z; }

        const gn=norm(this.g);
        const ref=Math.abs(gn.z)<0.9?{x:0,y:0,z:1}:{x:1,y:0,z:0};
        const e1=norm(cross(gn,ref)), e2=cross(gn,e1);

        const dotg=ax*gn.x+ay*gn.y+az*gn.z;
        const px=ax-dotg*gn.x, py=ay-dotg*gn.y, pz=az-dotg*gn.z;

        const u=px*e1.x+py*e1.y+pz*e1.z;
        const v=px*e2.x+py*e2.y+pz*e2.z;

        // smooth accel
        const beta=Math.exp(-dt/this.betaMs);
        this.uLP=beta*this.uLP+(1-beta)*u;
        this.vLP=beta*this.vLP+(1-beta)*v;
        const aPlanar=Math.hypot(this.uLP,this.vLP);

        // integrate to velocity with leak
        const velLeak=Math.exp(-dt/(aPlanar>=this.aFloor?this.velTauActive:this.velTauQuiet));
        this.uVel=velLeak*this.uVel+this.uLP*dt;
        this.vVel=velLeak*this.vVel+this.vLP*dt;

        // ZUPT-ish
        if (aPlanar < this.aFloor && Math.hypot(this.uVel,this.vVel) < this.vFloor) {
          this.uVel=0; this.vVel=0;
        }

        // integrate to position (light leak)
        const posLeak=Math.exp(-dt/this.posTau);
        this.uPos=posLeak*this.uPos+this.uVel*dt;
        this.vPos=posLeak*this.vPos+this.vVel*dt;

        // direction from position (stable, scale-free for angle)
        const thetaNow=Math.atan2(this.vPos,this.uPos);
        if (this.prevTheta==null) this.prevTheta=thetaNow;
        const dtheta=unwrap(thetaNow-this.prevTheta);
        this.prevTheta=thetaNow;

        const omega=Math.abs(dtheta)/dt; // rad/s

        // draw on a fixed ring (clean visual)
        const x=this.cx+this.rDraw*Math.cos(thetaNow);
        const y=this.cy+this.rDraw*Math.sin(thetaNow);
        if (!this.pathStarted){ this.ctx.beginPath(); this.ctx.moveTo(x,y); this.pathStarted=true; }
        else { this.ctx.lineTo(x,y); this.ctx.stroke(); }
        this._lastXPix=x; this._lastYPix=y; this._moveDot();

        // calibration
        if (this.calibrating){
          this.calibA.push(aPlanar);
          this.calibW.push(omega);
          if (now-this.calibStart>1000) this._finishCalibration();
          this._hud(aPlanar, Math.hypot(this.uVel,this.vVel), omega);
          return;
        }

        // spin veto (if gyro exists)
        let spinVeto=false;
        if (rr){
          const yawDeg=(rr.beta||0)*gn.x+(rr.gamma||0)*gn.y+(rr.alpha||0)*gn.z;
          spinVeto = Math.abs(yawDeg)>this.yawSpinVeto && aPlanar<this.spinLinearThresh;
        }

        // directional coherence via EWMA
        const cohDecay=Math.exp(-dt/this.cohTau);
        this.posEW = cohDecay*this.posEW + Math.max(0, dtheta);
        this.negEW = cohDecay*this.negEW + Math.max(0,-dtheta);
        const coh = (this.posEW+this.negEW)>1e-6 ? Math.max(this.posEW,this.negEW)/(this.posEW+this.negEW) : 0.5;

        // simple gate: need motion + min angular speed + coherence (no radius gate)
        const moving = Math.hypot(this.uVel,this.vVel) >= this.vFloor || aPlanar >= this.aFloor;
        const enoughOmega = omega >= (this.segStartT ? this.omegaOff : this.omegaMin);
        const gate = moving && enoughOmega && coh >= this.cohMin && !spinVeto;

        if (gate){
          if (this.segStartT==null){ this.segStartT=now; this.thetaAbsAccum=0; this.lastGoodMs=0; this.posEW=this.negEW=0; }
          this.thetaAbsAccum += Math.abs(dtheta);
          const prevProg=this.progress;
          this.progress = Math.min(1, this.thetaAbsAccum / this.progressTarget);
          this._renderProgress();

          if (prevProg<1 && this.progress>=1) this._maybeDetect(now, coh);
        } else {
          if (this.segStartT!=null){
            if (!this.lastGoodMs) this.lastGoodMs=now;
            if ((now-this.lastGoodMs) > this.gapMsAllow){ this._resetSegment(); this.lastGoodMs=0; }
          }
          this.progress=Math.max(0, this.progress-0.015);
          this._renderProgress();
        }

        this._hud(aPlanar, Math.hypot(this.uVel,this.vVel), omega);
        if (DEBUG && this.debugEl){
          this.debugEl.textContent =
            `gate:${gate?'1':'0'} prog:${Math.round(this.progress*100)}% `+
            `a:${aPlanar.toFixed(2)} v:${Math.hypot(this.uVel,this.vVel).toFixed(2)} `+
            `œâ:${(omega/DEG).toFixed(0)} coh:${coh.toFixed(2)} spin:${spinVeto?'Y':'N'}`;
        }
      }

      _maybeDetect(now, coh){
        const dur = this.segStartT ? (now - this.segStartT)/1000 : 0;
        const cooled = (now - this.lastDetectMs) > this.cooldownMs;
        if (dur>=this.segMinDur && dur<=this.segMaxDur && coh>=this.cohMin && cooled){
          this.lastDetectMs = now;
          this._onDetected();
          this._resetSegment();
        }
      }

      _resetSegment(){
        this.thetaAbsAccum=0; this.progress=0; this.segStartT=null;
        this._renderProgress();
      }

      _renderProgress(){
        const pct=Math.round(this.progress*100);
        const bar=document.getElementById('confidenceBar');
        const txt=document.getElementById('confidenceText');
        if (bar) bar.style.width=pct+'%';
        if (txt) txt.textContent=`Revolution progress: ${pct}%`;
      }

      _moveDot(){
        const x=(this._lastXPix??this.cx), y=(this._lastYPix??this.cy);
        const cssW=this.canvas.clientWidth, cssH=this.canvas.clientHeight;
        const cssX=(x/this.dpr)-cssW/2, cssY=(y/this.dpr)-cssH/2;
        this._uiX+=this.uiAlpha*(cssX-this._uiX);
        this._uiY+=this.uiAlpha*(cssY-this._uiY);
        this.dotEl.style.transform=`translate(calc(-50% + ${this._uiX}px), calc(-50% + ${this._uiY}px))`;
      }

      _hud(a,v,omega){
        const pa=document.getElementById('planarA'); if (pa) pa.textContent=a.toFixed(2);
        const pv=document.getElementById('planarV'); if (pv) pv.textContent=v.toFixed(2);
        const om=document.getElementById('omega');  if (om) om.textContent=(omega/DEG|0);
        const ch=document.getElementById('coh');    if (ch) ch.textContent=((this.posEW+this.negEW)>0?Math.max(this.posEW,this.negEW)/(this.posEW+this.negEW):0.5).toFixed(2);
      }

      _onDetected(){
        document.body.style.background='linear-gradient(135deg, #4CAF50 0%, #45a049 100%)';
        setTimeout(()=>{ document.body.style.background='linear-gradient(135deg, #667eea 0%, #764ba2 100%)'; }, 700);

        const status=document.getElementById('status');
        if (status){ status.textContent='üéâ FULL REVOLUTION'; status.className='status detecting';
          setTimeout(()=>{ status.textContent='Listening‚Ä¶ draw a smooth wrist/elbow circle'; status.className='status active'; }, 1500); }

        const history=document.getElementById('history');
        if (history){ const div=document.createElement('div'); div.className='detection-item';
          div.textContent=new Date().toLocaleTimeString()+': Full revolution'; history.appendChild(div); }

        if ('vibrate' in navigator) navigator.vibrate([160,100,160]);
      }
    }

    // ---- Wiring (no permission prompts) ----
    let detector=null, isActive=false, probeTimer=null;

    function startDetection(){
      start();
      // probe for events in 2s; if none, show inline tip
      let got=false;
      const probe=()=>{ got=true; window.removeEventListener('devicemotion', probe); };
      window.addEventListener('devicemotion', probe, {passive:true});
      clearTimeout(probeTimer);
      probeTimer=setTimeout(()=>{ if(!got) document.getElementById('sensorNotice').style.display='block'; }, 2000);
    }

    function start(){
      if (isActive) return;
      detector = new AngleAccumulatorDetector(
        document.getElementById('pathCanvas'),
        document.getElementById('gyroDot')
      );
      window.addEventListener('devicemotion', onMotion, {passive:true});
      isActive=true;

      const st=document.getElementById('status');
      if (st){ st.textContent='Calibrating‚Ä¶ hold still for 1s'; st.className='status'; }
      document.getElementById('startBtn').style.display='none';
      document.getElementById('stopBtn').style.display='inline-block';
    }

    function stopDetection(){
      if (!isActive) return;
      window.removeEventListener('devicemotion', onMotion);
      isActive=false;
      const st=document.getElementById('status');
      if (st){ st.textContent='Detection stopped'; st.className='status'; }
      document.getElementById('startBtn').style.display='inline-block';
      document.getElementById('stopBtn').style.display='none';
    }

    function onMotion(e){
      detector.addSample(
        e.acceleration || null,
        e.accelerationIncludingGravity || null,
        e.rotationRate || null   // optional; used only for spin veto
      );
    }

    function clearHistory(){
      const h=document.getElementById('history'); if(h) h.innerHTML='';
      document.getElementById('confidenceBar').style.width='0%';
      document.getElementById('confidenceText').textContent='Revolution progress: 0%';
      if (detector) detector.resetCanvas();
    }

    console.log('üì± Angle-accumulator detector ready: Start ‚Üí 1s still ‚Üí smooth wrist/elbow circle.');
  </script>
</body>
</html>
