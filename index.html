<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Wrist/Elbow Revolution ‚Äî Velocity Turning Angle (No Prompts)</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  body{
    font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;
    background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);
    min-height:100vh;display:flex;justify-content:center;align-items:center;color:#fff
  }
  .container{
    background:rgba(255,255,255,.1);backdrop-filter:blur(10px);
    border-radius:20px;padding:24px;width:min(420px,92vw);text-align:center;
    box-shadow:0 8px 32px rgba(0,0,0,.12);border:1px solid rgba(255,255,255,.2)
  }
  h1{font-size:22px;font-weight:700;margin-bottom:12px}
  .status{padding:12px;border-radius:10px;margin:12px 0;font-weight:600;border:1px solid rgba(255,255,255,.35)}
  .status.active{background:rgba(76,175,80,.18);border-color:rgba(76,175,80,.55)}
  .status.detecting{background:rgba(255,193,7,.2);border-color:rgba(255,193,7,.6);animation:pulse 1.5s infinite}
  @keyframes pulse{0%,100%{transform:scale(1)}50%{transform:scale(1.02)}}
  .visual{
    position:relative;width:280px;height:280px;margin:14px auto 10px;border-radius:50%;
    border:2px solid rgba(255,255,255,.28);background:rgba(255,255,255,.06);
    box-shadow:inset 0 0 0 2px rgba(255,255,255,.08);overflow:hidden
  }
  canvas#pathCanvas{width:100%;height:100%;display:block}
  #gyroDot{
    position:absolute;width:10px;height:10px;border-radius:50%;
    background:#4CAF50;top:50%;left:50%;transform:translate(-50%,-50%);
    box-shadow:0 0 0 2px rgba(0,0,0,.12);transition:transform .06s linear
  }
  .confidence-bar{width:100%;height:18px;background:rgba(255,255,255,.2);border-radius:10px;overflow:hidden;margin:8px 0}
  .confidence-fill{height:100%;width:0%;background:linear-gradient(90deg,#4CAF50,#FFC107,#FF5722);border-radius:10px;transition:width .18s ease}
  .data-display{background:rgba(0,0,0,.22);border-radius:10px;padding:10px;margin-top:10px;
    font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,'Liberation Mono',monospace;font-size:12px;text-align:left}
  .detection-history{max-height:160px;overflow-y:auto;background:rgba(0,0,0,.22);border-radius:10px;padding:10px;margin-top:12px;text-align:left}
  .detection-item{padding:4px 0;border-bottom:1px solid rgba(255,255,255,.12);font-size:13px}
  button{
    background:rgba(255,255,255,.18);border:1px solid rgba(255,255,255,.34);color:#fff;
    padding:10px 18px;border-radius:22px;cursor:pointer;font-size:15px;margin:8px 6px;transition:all .15s ease
  }
  button:hover{background:rgba(255,255,255,.28);transform:translateY(-1px)}
  button:active{transform:translateY(0)}
  #sensorNotice{display:none;margin-top:8px;padding:10px;border-radius:10px;background:rgba(255,107,107,.18);border:1px solid rgba(255,107,107,.5);font-size:13px;text-align:left}
  #debugInfo{display:none;margin-top:6px;font:12px ui-monospace,monospace;opacity:.9;text-align:left;white-space:pre-wrap}
</style>
</head>
<body>
  <div class="container">
    <h1>üîÑ Wrist/Elbow Revolution ‚Äî Velocity Turning Angle</h1>

    <div id="status" class="status">Tap ‚ÄúStart‚Äù, hold still 1s, then draw a smooth circle</div>

    <div class="visual">
      <canvas id="pathCanvas"></canvas>
      <div id="gyroDot"></div>
    </div>

    <div class="confidence-bar"><div id="confidenceBar" class="confidence-fill"></div></div>
    <div id="confidenceText">Revolution progress: 0%</div>

    <div>
      <button id="startBtn" onclick="startDetection()">Start</button>
      <button id="stopBtn" onclick="stopDetection()" style="display:none;">Stop</button>
      <button onclick="clearHistory()">Clear History</button>
    </div>

    <div class="data-display">
      <div>|a‚üÇg| (m/s¬≤): <span id="planarA">0.00</span></div>
      <div>|v| (a‚Üív): <span id="planarV">0.00</span></div>
      <div>turn œâ (deg/s): <span id="omega">0</span></div>
      <div>coherence: <span id="coh">0.00</span></div>
      <div>path length (m est): <span id="plen">0.00</span></div>
    </div>

    <div class="detection-history">
      <strong>Detection History:</strong>
      <div id="history"></div>
    </div>

    <div id="sensorNotice">
      <strong>No motion data received.</strong><br>
      If you‚Äôre on iPhone/iPad: Safari ‚Üí tap ‚ÄúaA‚Äù ‚Üí Website Settings ‚Üí <em>Motion &amp; Orientation Access</em> ‚Üí ON, then reload.<br>
      On Android (Chrome): lock icon ‚Üí Site settings ‚Üí <em>Motion sensors</em> ‚Üí Allow.
    </div>

    <div id="debugInfo"></div>
  </div>

<script>
/* ========= NO-PROMPT VERSION ========= */
const DEBUG = false;

/* ---- helpers ---- */
const TAU = Math.PI*2, DEG = Math.PI/180;
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
const unwrap=d=>(d>Math.PI?d-TAU:d<-Math.PI?d+TAU:d);
const hypot3=(x,y,z)=>Math.sqrt(x*x+y*y+z*z);
function cross(a,b){return {x:a.y*b.z-a.z*b.y,y:a.z*b.x-a.x*b.z,z:a.x*b.y-a.y*b.x};}
function norm(v){const n=hypot3(v.x,v.y,v.z)||1;return {x:v.x/n,y:v.y/n,z:v.z/n};}
function median(a){if(!a.length)return 0;const s=[...a].sort((x,y)=>x-y);const m=Math.floor(s.length/2);return s.length%2?s[m]:(s[m-1]+s[m])/2;}
function mad(a,m=null){if(!a.length)return 0;if(m==null)m=median(a);const d=a.map(x=>Math.abs(x-m));return median(d);}

class VelocityTurningDetector{
  constructor(canvas,dot){
    /* --- friendly tunables (you can tweak these few) --- */
    this.progressTarget = TAU*0.7;     // ~306¬∞ counts as a revolution
    this.segMinDur = 0.18;              // allow fast loops
    this.segMaxDur = 12.0;
    this.gapMsAllow = 350;

    this.betaMs = 0.08;                 // accel smoothing (~80ms)
    this.gTau   = 0.25;                 // gravity LPF time constant

    this.velTauActive = 2.5;            // slower leak when moving (longer memory)
    this.velTauQuiet  = 0.40;           // faster leak when quiet
    this.posTau       = 10.0;           // very light leak on position

    // thresholds (auto-calibrated then clamped)
    this.aFloor = 0.05;                 // m/s¬≤
    this.vFloor = 0.05;                 // speed units
    this.omegaMin = 0.1;               // rad/s (~14¬∞/s) to count as "turning"
    this.omegaOff = 0.6;

    // consistency of turning direction (0.5=random, 1.0=single direction)
    this.cohTau = 1.0;                  // seconds
    this.cohMin = 0.52;                 // slightly > 0.5 to reject jitter

    // require some literal movement to avoid tiny in-place wiggles
    this.minPathLen = 0.12;             // meters (estimated from a‚Üív integration)

    // ---- state ----
    this.canvas=canvas; this.ctx=canvas.getContext('2d'); this.dot=dot;
    this.dpr=Math.max(1,window.devicePixelRatio||1);
    this.uiAlpha=0.25; this._uiX=0; this._uiY=0;

    this.g=null; this.lastT=0;

    this.uLP=0; this.vLP=0;          // smoothed planar accel
    this.uVel=0; this.vVel=0;        // integrated velocity
    this.uPos=0; this.vPos=0;        // integrated position
    this.prevPhi=null;               // angle of velocity
    this.turnAbs=0;                  // sum |Œîphi|
    this.progress=0;
    this.segStart=null; this.lastGoodMs=0;

    this.posEW=0; this.negEW=0;      // coherence EWMA
    this.pathLen=0;                  // ‚à´|v|dt

    this.lastDetectMs=0; this.cooldownMs=1200;

    this.debugEl=document.getElementById('debugInfo'); if (DEBUG) this.debugEl.style.display='block';

    window.addEventListener('resize',()=>{this.resize();this.resetCanvas();},{passive:true});
    this.resize(); this.resetCanvas();

    // 1s auto-calibration
    this.calibrating=true; this.calibStart=0; this.calibA=[]; this.calibW=[];
    this._startCalibration();
  }

  resize(){
    const cw=this.canvas.clientWidth, ch=this.canvas.clientHeight;
    this.canvas.width=Math.floor(cw*this.dpr);
    this.canvas.height=Math.floor(ch*this.dpr);
    this.w=this.canvas.width; this.h=this.canvas.height;
    this.cx=this.w/2; this.cy=this.h/2;
    this.padPx=6*this.dpr;
    this.R=Math.min(this.cx,this.cy)-this.padPx;
    this.rDraw=this.R*0.65;

    this.ctx.setTransform(1,0,0,1,0,0);
    this.ctx.lineWidth=2*this.dpr; this.ctx.lineCap='round'; this.ctx.lineJoin='round';
    this.ctx.strokeStyle='rgba(255,255,255,.95)';
  }

  resetCanvas(){
    this.ctx.clearRect(0,0,this.w,this.h);
    this.ctx.save(); this.ctx.globalAlpha=.18;
    this.ctx.beginPath(); this.ctx.arc(this.cx,this.cy,this.R,0,TAU); this.ctx.stroke(); this.ctx.restore();
    this.ctx.save(); this.ctx.beginPath(); this.ctx.arc(this.cx,this.cy,this.R-this.ctx.lineWidth*0.5,0,TAU); this.ctx.clip();
    this.pathStarted=false;

    this.uLP=this.vLP=0; this.uVel=this.vVel=0; this.uPos=this.vPos=0;
    this.prevPhi=null; this.turnAbs=0; this.progress=0;
    this.segStart=null; this.lastGoodMs=0;
    this.posEW=this.negEW=0; this.pathLen=0;

    this._lastXPix=this.cx; this._lastYPix=this.cy;
    this._renderProgress(); this._moveDot();
  }

  _startCalibration(){
    this.calibrating=true; this.calibA.length=0; this.calibW.length=0; this.calibStart=performance.now();
    const st=document.getElementById('status'); if (st){ st.textContent='Calibrating‚Ä¶ hold still for 1s'; st.className='status'; }
  }
  _finishCalibration(){
    const aMed=median(this.calibA), aMAD=mad(this.calibA,aMed)*1.4826;
    const wMed=median(this.calibW), wMAD=mad(this.calibW,wMed)*1.4826;
    this.aFloor   = Math.min(0.12, Math.max(0.03, aMed + 6*aMAD));
    this.vFloor   = Math.min(0.12, 0.04 + 4*aMAD); // tie a bit to accel noise
    this.omegaMin = Math.min(0.70, Math.max(0.18, wMed + 4*wMAD));
    this.omegaOff = Math.min(0.55, Math.max(0.15, wMed + 3*wMAD));
    this.calibrating=false;
    const st=document.getElementById('status'); if (st){ st.textContent='Listening‚Ä¶ draw a smooth wrist/elbow circle'; st.className='status active'; }
  }

  addSample(acc,accG,rr){
    const now=performance.now();
    const dt=this.lastT?Math.max(0.001,(now-this.lastT)/1000):0.016;
    this.lastT=now;

    // --- gravity init/update ---
    if(!this.g){
      if(accG && Number.isFinite(accG.x)) this.g={x:accG.x,y:accG.y,z:accG.z};
      else if(acc && Number.isFinite(acc.x)){ const m=hypot3(acc.x,acc.y,acc.z); if(m>7.5) this.g={x:acc.x,y:acc.y,z:acc.z}; else return; }
      else return;
    } else {
      const a=Math.exp(-dt/this.gTau);
      if(accG && Number.isFinite(accG.x)){
        this.g.x=a*this.g.x+(1-a)*accG.x; this.g.y=a*this.g.y+(1-a)*accG.y; this.g.z=a*this.g.z+(1-a)*accG.z;
      }
    }

    // --- project to plane ‚üÇ g ---
    let ax=0,ay=0,az=0;
    if(acc && Number.isFinite(acc.x)){ ax=acc.x; ay=acc.y; az=acc.z; }
    else if(accG){ ax=accG.x-this.g.x; ay=accG.y-this.g.y; az=accG.z-this.g.z; }

    const gn=norm(this.g);
    const ref=Math.abs(gn.z)<0.9?{x:0,y:0,z:1}:{x:1,y:0,z:0};
    const e1=norm(cross(gn,ref)), e2=cross(gn,e1);

    const dotg=ax*gn.x+ay*gn.y+az*gn.z;
    const px=ax-dotg*gn.x, py=ay-dotg*gn.y, pz=az-dotg*gn.z;

    const u=px*e1.x+py*e1.y+pz*e1.z;
    const v=px*e2.x+py*e2.y+pz*e2.z;

    // --- smooth accel ---
    const beta=Math.exp(-dt/this.betaMs);
    this.uLP=beta*this.uLP+(1-beta)*u;
    this.vLP=beta*this.vLP+(1-beta)*v;
    const aPlanar=Math.hypot(this.uLP,this.vLP);

    // --- integrate to velocity with leak (active vs quiet) ---
    const leak=Math.exp(-dt/(aPlanar>=this.aFloor?this.velTauActive:this.velTauQuiet));
    this.uVel=leak*this.uVel + this.uLP*dt;
    this.vVel=leak*this.vVel + this.vLP*dt;

    // ZUPT-ish
    const speed=Math.hypot(this.uVel,this.vVel);
    if(aPlanar<this.aFloor && speed<this.vFloor){ this.uVel=0; this.vVel=0; }

    // --- integrate to position (light leak) + path length ---
    const posLeak=Math.exp(-dt/this.posTau);
    this.uPos=posLeak*this.uPos + this.uVel*dt;
    this.vPos=posLeak*this.vPos + this.vVel*dt;
    this.pathLen += speed*dt;

    // --- velocity direction & turning angle ---
    const phiNow=Math.atan2(this.vVel,this.uVel);
    if(this.prevPhi==null) this.prevPhi=phiNow;
    const dphi=unwrap(phiNow - this.prevPhi);
    this.prevPhi=phiNow;

    const omega=Math.abs(dphi)/dt; // rad/s

    // --- draw on a fixed ring for clarity ---
    const x=this.cx + this.rDraw*Math.cos(phiNow);
    const y=this.cy + this.rDraw*Math.sin(phiNow);
    if(!this.pathStarted){ this.ctx.beginPath(); this.ctx.moveTo(x,y); this.pathStarted=true; }
    else { this.ctx.lineTo(x,y); this.ctx.stroke(); }
    this._lastXPix=x; this._lastYPix=y; this._moveDot();

    // --- calibration phase ---
    if(this.calibrating){
      this.calibA.push(aPlanar);
      this.calibW.push(omega);
      if(now - this.calibStart > 1000) this._finishCalibration();
      this._hud(aPlanar, speed, omega);
      return;
    }

    // --- direction coherence (EWMA) ---
    const cohDecay=Math.exp(-dt/this.cohTau);
    this.posEW=cohDecay*this.posEW + Math.max(0, dphi);
    this.negEW=cohDecay*this.negEW + Math.max(0,-dphi);
    const coh=(this.posEW+this.negEW)>1e-6 ? Math.max(this.posEW,this.negEW)/(this.posEW+this.negEW) : 0.5;

    // --- gate: moving + minimal turning speed + direction consistency ---
    const moving = (speed>=this.vFloor) || (aPlanar>=this.aFloor);
    const enoughOmega = omega >= (this.segStart?this.omegaOff:this.omegaMin);
    const gate = moving && enoughOmega && coh >= this.cohMin;

    if(gate){
      if(!this.segStart){ this.segStart=now; this.turnAbs=0; this.pathLen=0; this.posEW=this.negEW=0; }
      this.turnAbs += Math.abs(dphi);

      const prevProg=this.progress;
      this.progress = Math.min(1, this.turnAbs / this.progressTarget);
      this._renderProgress();

      if(prevProg<1 && this.progress>=1){
        const dur=(now - this.segStart)/1000;
        const cooled=(now - this.lastDetectMs) > this.cooldownMs;
        if(dur>=this.segMinDur && dur<=this.segMaxDur && this.pathLen>=this.minPathLen && coh>=this.cohMin && cooled){
          this.lastDetectMs=now; this._onDetected(); this._resetSegment();
        }else{
          // if failed final checks, keep running but don‚Äôt fire yet
        }
      }
      this.lastGoodMs=now;
    } else {
      if(this.segStart){
        if(!this.lastGoodMs) this.lastGoodMs=now;
        if((now - this.lastGoodMs) > this.gapMsAllow){ this._resetSegment(); this.lastGoodMs=0; }
      }
      this.progress=Math.max(0, this.progress - 0.015);
      this._renderProgress();
    }

    this._hud(aPlanar, speed, omega);
    if(DEBUG && this.debugEl){
      this.debugEl.textContent=
        `gate:${gate?'1':'0'} prog:${Math.round(this.progress*100)}% `+
        `a:${aPlanar.toFixed(2)} v:${speed.toFixed(2)} œâ:${(omega/DEG|0)} `+
        `coh:${coh.toFixed(2)} path:${this.pathLen.toFixed(2)}`;
    }
  }

  _resetSegment(){
    this.turnAbs=0; this.progress=0; this.segStart=null; this.pathLen=0;
    this._renderProgress();
  }

  _renderProgress(){
    const pct=Math.round(this.progress*100);
    const bar=document.getElementById('confidenceBar');
    const txt=document.getElementById('confidenceText');
    if(bar) bar.style.width=pct+'%';
    if(txt) txt.textContent=`Revolution progress: ${pct}%`;
  }

  _moveDot(){
    const x=(this._lastXPix??this.cx), y=(this._lastYPix??this.cy);
    const cssW=this.canvas.clientWidth, cssH=this.canvas.clientHeight;
    const cssX=(x/this.dpr)-cssW/2, cssY=(y/this.dpr)-cssH/2;
    this._uiX+=this.uiAlpha*(cssX-this._uiX);
    this._uiY+=this.uiAlpha*(cssY-this._uiY);
    this.dot.style.transform=`translate(calc(-50% + ${this._uiX}px), calc(-50% + ${this._uiY}px))`;
  }

  _hud(a,v,omega){
    const pa=document.getElementById('planarA'); if(pa) pa.textContent=a.toFixed(2);
    const pv=document.getElementById('planarV'); if(pv) pv.textContent=v.toFixed(2);
    const om=document.getElementById('omega');  if(om) om.textContent=(omega/DEG|0);
    const pl=document.getElementById('plen');   if(pl) pl.textContent=this.pathLen.toFixed(2);
  }

  _onDetected(){
    document.body.style.background='linear-gradient(135deg,#4CAF50 0%,#45a049 100%)';
    setTimeout(()=>{document.body.style.background='linear-gradient(135deg,#667eea 0%,#764ba2 100%)';},700);

    const s=document.getElementById('status');
    if(s){ s.textContent='üéâ FULL REVOLUTION'; s.className='status detecting';
      setTimeout(()=>{ s.textContent='Listening‚Ä¶ draw a smooth wrist/elbow circle'; s.className='status active'; },1500); }

    const h=document.getElementById('history');
    if(h){ const div=document.createElement('div'); div.className='detection-item';
      div.textContent=new Date().toLocaleTimeString()+': Full revolution'; h.appendChild(div); }
    if('vibrate' in navigator) navigator.vibrate([160,100,160]);
  }
}

/* ---- wiring ---- */
let detector=null,isActive=false,probeTimer=null;

function startDetection(){
  start();
  // probe for events in 2s; show inline tip if none
  let got=false;
  const probe=()=>{got=true;window.removeEventListener('devicemotion',probe);};
  window.addEventListener('devicemotion',probe,{passive:true});
  clearTimeout(probeTimer);
  probeTimer=setTimeout(()=>{ if(!got) document.getElementById('sensorNotice').style.display='block'; },2000);
}
function start(){
  if(isActive) return;
  detector=new VelocityTurningDetector(
    document.getElementById('pathCanvas'),
    document.getElementById('gyroDot')
  );
  window.addEventListener('devicemotion',onMotion,{passive:true});
  isActive=true;
  const st=document.getElementById('status');
  if(st){st.textContent='Calibrating‚Ä¶ hold still for 1s'; st.className='status';}
  document.getElementById('startBtn').style.display='none';
  document.getElementById('stopBtn').style.display='inline-block';
}
function stopDetection(){
  if(!isActive) return;
  window.removeEventListener('devicemotion',onMotion);
  isActive=false;
  const st=document.getElementById('status');
  if(st){st.textContent='Detection stopped'; st.className='status';}
  document.getElementById('startBtn').style.display='inline-block';
  document.getElementById('stopBtn').style.display='none';
}
function onMotion(e){
  detector.addSample(
    e.acceleration || null,
    e.accelerationIncludingGravity || null,
    e.rotationRate || null
  );
}
function clearHistory(){
  const h=document.getElementById('history'); if(h) h.innerHTML='';
  document.getElementById('confidenceBar').style.width='0%';
  document.getElementById('confidenceText').textContent='Revolution progress: 0%';
  if(detector) detector.resetCanvas();
}
console.log('üì± Velocity-turn detector ready: Start ‚Üí 1s still ‚Üí smooth wrist/elbow circle.');
</script>
</body>
</html>
