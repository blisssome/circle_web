<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Circle vs Shake Detector</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  body{
    font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;
    background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);
    min-height:100vh;display:flex;justify-content:center;align-items:center;color:#fff
  }
  .container{
    background:rgba(255,255,255,.1);backdrop-filter:blur(10px);
    border-radius:20px;padding:24px;width:min(420px,92vw);text-align:center;
    box-shadow:0 8px 32px rgba(0,0,0,.12);border:1px solid rgba(255,255,255,.2)
  }
  h1{font-size:22px;font-weight:700;margin-bottom:12px}
  .status{padding:12px;border-radius:10px;margin:12px 0;font-weight:600;border:1px solid rgba(255,255,255,.35)}
  .status.active{background:rgba(76,175,80,.18);border-color:rgba(76,175,80,.55)}
  .status.circle{background:rgba(33,150,243,.2);border-color:rgba(33,150,243,.6);animation:pulse 1.5s infinite}
  .status.shake{background:rgba(255,87,34,.2);border-color:rgba(255,87,34,.6);animation:pulse 1.5s infinite}
  @keyframes pulse{0%,100%{transform:scale(1)}50%{transform:scale(1.02)}}
  .visual{
    position:relative;width:280px;height:280px;margin:14px auto 10px;border-radius:50%;
    border:2px solid rgba(255,255,255,.28);background:rgba(255,255,255,.06);
    box-shadow:inset 0 0 0 2px rgba(255,255,255,.08);overflow:hidden
  }
  canvas#pathCanvas{width:100%;height:100%;display:block}
  #motionDot{
    position:absolute;width:12px;height:12px;border-radius:50%;
    background:#4CAF50;top:50%;left:50%;transform:translate(-50%,-50%);
    box-shadow:0 0 0 2px rgba(0,0,0,.12);transition:transform .08s ease
  }
  .dual-progress{display:flex;gap:8px;margin:8px 0}
  .progress-container{flex:1}
  .progress-label{font-size:12px;margin-bottom:4px;opacity:0.8}
  .progress-bar{width:100%;height:16px;background:rgba(255,255,255,.2);border-radius:8px;overflow:hidden}
  .progress-fill{height:100%;width:0%;border-radius:8px;transition:width .2s ease}
  .circle-fill{background:linear-gradient(90deg,#2196F3,#03DAC6)}
  .shake-fill{background:linear-gradient(90deg,#FF5722,#FF9800)}
  .data-display{background:rgba(0,0,0,.22);border-radius:10px;padding:12px;margin-top:12px;
    font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,'Liberation Mono',monospace;font-size:11px;text-align:left}
  .data-row{display:flex;justify-content:space-between;margin:3px 0}
  .detection-history{max-height:140px;overflow-y:auto;background:rgba(0,0,0,.22);border-radius:10px;padding:10px;margin-top:12px;text-align:left}
  .detection-item{padding:4px 0;border-bottom:1px solid rgba(255,255,255,.12);font-size:13px}
  .detection-item.circle{color:#64B5F6}
  .detection-item.shake{color:#FF8A65}
  button{
    background:rgba(255,255,255,.18);border:1px solid rgba(255,255,255,.34);color:#fff;
    padding:10px 18px;border-radius:22px;cursor:pointer;font-size:15px;margin:8px 6px;transition:all .15s ease
  }
  button:hover{background:rgba(255,255,255,.28);transform:translateY(-1px)}
  button:active{transform:translateY(0)}
  #sensorNotice{display:none;margin-top:8px;padding:10px;border-radius:10px;background:rgba(255,107,107,.18);border:1px solid rgba(255,107,107,.5);font-size:13px;text-align:left}
</style>
</head>
<body>
  <div class="container">
    <h1>🔄 Circle vs Shake Detector</h1>

    <div id="status" class="status">Move your arm - circles or shakes will be detected</div>

    <div class="visual">
      <canvas id="pathCanvas"></canvas>
      <div id="motionDot"></div>
    </div>

    <div class="dual-progress">
      <div class="progress-container">
        <div class="progress-label">Circle Progress</div>
        <div class="progress-bar"><div id="circleBar" class="progress-fill circle-fill"></div></div>
      </div>
      <div class="progress-container">
        <div class="progress-label">Shake Intensity</div>
        <div class="progress-bar"><div id="shakeBar" class="progress-fill shake-fill"></div></div>
      </div>
    </div>

    <div>
      <button id="startBtn" onclick="startDetection()">Start Detection</button>
      <button id="stopBtn" onclick="stopDetection()" style="display:none;">Stop</button>
      <button onclick="clearHistory()">Clear History</button>
    </div>

    <div class="data-display">
      <div class="data-row"><span>Motion Type:</span> <span id="motionType">None</span></div>
      <div class="data-row"><span>Circular Score:</span> <span id="circleScore">0%</span></div>
      <div class="data-row"><span>Shake Score:</span> <span id="shakeScore">0%</span></div>
      <div class="data-row"><span>Angular Vel:</span> <span id="angularVel">0 °/s</span></div>
      <div class="data-row"><span>Frequency:</span> <span id="frequency">0 Hz</span></div>
      <div class="data-row"><span>Radius Est:</span> <span id="radius">0 cm</span></div>
    </div>

    <div class="detection-history">
      <strong>Detection History:</strong>
      <div id="history"></div>
    </div>

    <div id="sensorNotice">
      <strong>No motion data received.</strong><br>
      iPhone/iPad: Safari → "aA" → Website Settings → Motion & Orientation Access → ON, then reload.<br>
      Android Chrome: lock icon → Site settings → Motion sensors → Allow.
    </div>
  </div>

<script>
const TAU = Math.PI * 2;
const DEG = 180 / Math.PI;

class MotionDetector {
  constructor(canvas, dot) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.dot = dot;
    
    // State variables
    this.isCalibrating = true;
    this.calibrationStart = 0;
    this.gravity = null;
    this.lastTime = 0;
    this.motionHistory = [];
    this.maxHistoryLength = 100; // 2 seconds at 50Hz
    
    // Circle detection
    this.circleProgress = 0;
    this.totalRotation = 0;
    this.circleStartTime = 0;
    this.lastAngle = null;
    this.circleCenter = { x: 0, y: 0 };
    this.circleRadius = 0;
    this.circleQuality = 0;
    
    // Shake detection  
    this.shakeIntensity = 0;
    this.shakeFrequency = 0;
    this.rapidChanges = 0;
    this.shakeStartTime = 0;
    
    // Smoothing
    this.smoothedAccel = { x: 0, y: 0 };
    this.prevAccel = { x: 0, y: 0 };
    
    // Thresholds
    this.circleMinRadius = 0.08;
    this.circleMaxRadius = 0.7;
    this.circleMinTime = 0.6;
    this.circleMaxTime = 4.0;
    this.shakeThreshold = 2.0;
    this.shakeMinFreq = 2.0; // Hz
    
    this._setupCanvas();
    this._resetDetection();
  }
  
  _setupCanvas() {
    const rect = this.canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    
    this.canvas.width = rect.width * dpr;
    this.canvas.height = rect.height * dpr;
    this.ctx.scale(dpr, dpr);
    
    this.canvasWidth = rect.width;
    this.canvasHeight = rect.height;
    this.centerX = this.canvasWidth / 2;
    this.centerY = this.canvasHeight / 2;
    this.visualRadius = Math.min(this.canvasWidth, this.canvasHeight) * 0.35;
    
    this.ctx.lineWidth = 2;
    this.ctx.lineCap = 'round';
    this._clearCanvas();
  }
  
  _clearCanvas() {
    this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
    
    // Draw reference circle
    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
    this.ctx.beginPath();
    this.ctx.arc(this.centerX, this.centerY, this.visualRadius, 0, TAU);
    this.ctx.stroke();
    
    this.pathStarted = false;
  }
  
  _resetDetection() {
    // Circle reset
    this.circleProgress = 0;
    this.totalRotation = 0;
    this.lastAngle = null;
    this.circleStartTime = 0;
    this.circleQuality = 0;
    
    // Shake reset  
    this.shakeIntensity = 0;
    this.rapidChanges = 0;
    this.shakeStartTime = 0;
    
    this.motionHistory = [];
    this._updateUI();
    this._clearCanvas();
  }
  
  addMotionSample(acceleration, accelerationGravity, rotationRate, timestamp) {
    const now = timestamp || performance.now();
    const dt = this.lastTime ? Math.max(0.001, (now - this.lastTime) / 1000) : 1/60;
    this.lastTime = now;
    
    // Establish gravity vector
    if (!this.gravity && accelerationGravity) {
      this.gravity = { x: accelerationGravity.x, y: accelerationGravity.y, z: accelerationGravity.z };
      return;
    }
    if (!this.gravity) return;
    
    // Update gravity estimate
    if (accelerationGravity) {
      const alpha = 0.02;
      this.gravity.x = (1 - alpha) * this.gravity.x + alpha * accelerationGravity.x;
      this.gravity.y = (1 - alpha) * this.gravity.y + alpha * accelerationGravity.y;
      this.gravity.z = (1 - alpha) * this.gravity.z + alpha * accelerationGravity.z;
    }
    
    // Calculate linear acceleration
    let linearAccel = { x: 0, y: 0, z: 0 };
    if (acceleration) {
      linearAccel = acceleration;
    } else if (accelerationGravity) {
      linearAccel = {
        x: accelerationGravity.x - this.gravity.x,
        y: accelerationGravity.y - this.gravity.y,
        z: accelerationGravity.z - this.gravity.z
      };
    }
    
    // Smooth acceleration
    const smoothing = 0.15;
    this.smoothedAccel.x = (1 - smoothing) * this.smoothedAccel.x + smoothing * linearAccel.x;
    this.smoothedAccel.y = (1 - smoothing) * this.smoothedAccel.y + smoothing * linearAccel.y;
    
    const accelMag = Math.sqrt(this.smoothedAccel.x**2 + this.smoothedAccel.y**2);
    
    // Store motion sample
    const sample = {
      time: now,
      accel: { x: linearAccel.x, y: linearAccel.y },
      smoothAccel: { x: this.smoothedAccel.x, y: this.smoothedAccel.y },
      accelMag: accelMag,
      dt: dt
    };
    
    this.motionHistory.push(sample);
    if (this.motionHistory.length > this.maxHistoryLength) {
      this.motionHistory.shift();
    }
    
    // Calibration
    if (this.isCalibrating) {
      if (this.calibrationStart === 0) this.calibrationStart = now;
      if (now - this.calibrationStart > 800) {
        this.isCalibrating = false;
        const status = document.getElementById('status');
        if (status) {
          status.textContent = 'Ready! Make circles or shakes';
          status.className = 'status active';
        }
      }
      return;
    }
    
    // Run both detectors simultaneously
    this._detectCircles(sample);
    this._detectShakes(sample);
    
    // Update visualization
    this._updateVisualization(sample);
    this._updateUI();
    
    this.prevAccel = { x: linearAccel.x, y: linearAccel.y };
  }
  
  _detectCircles(sample) {
    if (this.motionHistory.length < 20) return;
    
    // Get recent motion for analysis
    const recent = this.motionHistory.slice(-40); // ~0.8 seconds
    
    // Find motion center using weighted average
    let weightedX = 0, weightedY = 0, totalWeight = 0;
    recent.forEach(s => {
      const weight = s.accelMag + 0.1; // Avoid zero weights
      weightedX += s.smoothAccel.x * weight;
      weightedY += s.smoothAccel.y * weight;
      totalWeight += weight;
    });
    
    if (totalWeight > 0) {
      this.circleCenter.x = weightedX / totalWeight;
      this.circleCenter.y = weightedY / totalWeight;
    }
    
    // Calculate radius and circular quality
    const distances = recent.map(s => Math.sqrt(
      (s.smoothAccel.x - this.circleCenter.x)**2 + 
      (s.smoothAccel.y - this.circleCenter.y)**2
    ));
    
    if (distances.length > 0) {
      this.circleRadius = distances.reduce((a, b) => a + b) / distances.length;
      
      // Calculate radius consistency (lower variance = more circular)
      const avgDist = this.circleRadius;
      const variance = distances.reduce((sum, d) => sum + (d - avgDist)**2, 0) / distances.length;
      const consistency = avgDist > 0.05 ? Math.max(0, 1 - Math.sqrt(variance) / avgDist) : 0;
      
      // Check for continuous rotation
      const rotationScore = this._checkRotation(recent);
      
      // Combine scores for circle quality
      this.circleQuality = (consistency * 0.6 + rotationScore * 0.4);
    }
    
    // Track angular position for rotation measurement
    if (this.circleRadius > this.circleMinRadius) {
      const dx = sample.smoothAccel.x - this.circleCenter.x;
      const dy = sample.smoothAccel.y - this.circleCenter.y;
      const angle = Math.atan2(dy, dx);
      
      if (this.lastAngle !== null) {
        let deltaAngle = angle - this.lastAngle;
        if (deltaAngle > Math.PI) deltaAngle -= TAU;
        if (deltaAngle < -Math.PI) deltaAngle += TAU;
        
        // Start tracking if quality is good
        if (this.circleQuality > 0.4 && Math.abs(deltaAngle) > 0.02) {
          if (this.circleStartTime === 0) {
            this.circleStartTime = sample.time;
            this.totalRotation = 0;
          }
          this.totalRotation += Math.abs(deltaAngle);
        }
      }
      this.lastAngle = angle;
    }
    
    // Update progress
    this.circleProgress = Math.min(1, this.totalRotation / TAU);
    
    // Check for complete circle
    if (this.circleProgress > 0.85 && this.circleStartTime > 0) {
      const duration = (sample.time - this.circleStartTime) / 1000;
      
      if (duration >= this.circleMinTime && 
          duration <= this.circleMaxTime &&
          this.circleQuality > 0.5 &&
          this.circleRadius >= this.circleMinRadius &&
          this.circleRadius <= this.circleMaxRadius) {
        
        this._onCircleDetected(duration, this.circleRadius, this.circleQuality);
      }
    }
    
    // Reset if motion becomes non-circular or stops
    if (sample.accelMag < 0.3 || this.circleQuality < 0.2) {
      if (this.circleStartTime > 0 && sample.time - this.circleStartTime > 1500) {
        this._resetCircleDetection();
      }
    }
  }
  
  _checkRotation(samples) {
    if (samples.length < 10) return 0;
    
    let totalAngleChange = 0;
    let consistentDirection = 0;
    let lastDirection = 0;
    
    for (let i = 1; i < samples.length; i++) {
      const curr = samples[i].smoothAccel;
      const prev = samples[i-1].smoothAccel;
      
      const angle1 = Math.atan2(prev.y - this.circleCenter.y, prev.x - this.circleCenter.x);
      const angle2 = Math.atan2(curr.y - this.circleCenter.y, curr.x - this.circleCenter.x);
      
      let deltaAngle = angle2 - angle1;
      if (deltaAngle > Math.PI) deltaAngle -= TAU;
      if (deltaAngle < -Math.PI) deltaAngle += TAU;
      
      if (Math.abs(deltaAngle) > 0.02) {
        totalAngleChange += Math.abs(deltaAngle);
        const direction = Math.sign(deltaAngle);
        
        if (lastDirection === 0) lastDirection = direction;
        else if (direction === lastDirection) consistentDirection++;
      }
    }
    
    const rotationAmount = Math.min(1, totalAngleChange / (Math.PI * 0.5));
    const directionConsistency = samples.length > 5 ? consistentDirection / (samples.length - 1) : 0;
    
    return rotationAmount * (0.3 + 0.7 * directionConsistency);
  }
  
  _detectShakes(sample) {
    if (this.motionHistory.length < 10) return;
    
    // Analyze rapid acceleration changes (characteristic of shaking)
    const recent = this.motionHistory.slice(-20); // Last 0.4 seconds
    
    let rapidChangeCount = 0;
    let totalAccelChange = 0;
    let avgFrequency = 0;
    
    for (let i = 1; i < recent.length; i++) {
      const curr = recent[i];
      const prev = recent[i-1];
      
      // Calculate acceleration change
      const accelChange = Math.sqrt(
        (curr.smoothAccel.x - prev.smoothAccel.x)**2 +
        (curr.smoothAccel.y - prev.smoothAccel.y)**2
      );
      
      totalAccelChange += accelChange;
      
      // Check for rapid direction changes (shaking pattern)
      if (accelChange > 1.0) {
        rapidChangeCount++;
      }
      
      // Estimate frequency from zero crossings
      const dotProduct = curr.smoothAccel.x * prev.smoothAccel.x + 
                        curr.smoothAccel.y * prev.smoothAccel.y;
      if (dotProduct < 0 && (curr.accelMag > 0.5 && prev.accelMag > 0.5)) {
        avgFrequency += 1.0 / Math.max(0.02, curr.dt);
      }
    }
    
    // Calculate shake metrics
    const changeRate = rapidChangeCount / recent.length;
    const avgAccelChange = totalAccelChange / recent.length;
    this.shakeFrequency = avgFrequency / Math.max(1, recent.length - 1);
    
    // Shake intensity based on change rate and magnitude
    this.shakeIntensity = Math.min(1, (changeRate * 2 + avgAccelChange / 3) * 0.5);
    
    // Detect shake event
    if (this.shakeIntensity > 0.6 && 
        this.shakeFrequency > this.shakeMinFreq && 
        sample.accelMag > this.shakeThreshold) {
      
      if (this.shakeStartTime === 0) {
        this.shakeStartTime = sample.time;
      } else if (sample.time - this.shakeStartTime > 200) { // 200ms minimum shake duration
        this._onShakeDetected(this.shakeIntensity, this.shakeFrequency);
        this.shakeStartTime = sample.time; // Reset for next shake
      }
    } else if (this.shakeIntensity < 0.3) {
      this.shakeStartTime = 0; // Reset if shaking stops
    }
  }
  
  _resetCircleDetection() {
    this.circleProgress = 0;
    this.totalRotation = 0;
    this.lastAngle = null;
    this.circleStartTime = 0;
    this.circleQuality = 0;
  }
  
  _updateVisualization(sample) {
    // Draw motion path
    const scale = 50; // Scale factor for visualization
    const x = this.centerX + (sample.smoothAccel.x * scale);
    const y = this.centerY + (sample.smoothAccel.y * scale);
    
    // Color based on dominant motion type
    let hue = 120; // Default green
    if (this.shakeIntensity > 0.5) hue = 15; // Orange for shake
    else if (this.circleQuality > 0.4) hue = 200; // Blue for circle
    
    this.ctx.strokeStyle = `hsl(${hue}, 70%, 60%)`;
    this.ctx.globalAlpha = 0.7;
    
    if (!this.pathStarted || this.motionHistory.length < 2) {
      this.ctx.beginPath();
      this.ctx.moveTo(x, y);
      this.pathStarted = true;
    } else {
      this.ctx.lineTo(x, y);
      this.ctx.stroke();
    }
    
    // Update dot position
    this.dot.style.transform = `translate(${x - this.centerX}px, ${y - this.centerY}px)`;
  }
  
  _updateUI() {
    // Progress bars
    const circleBar = document.getElementById('circleBar');
    const shakeBar = document.getElementById('shakeBar');
    
    if (circleBar) circleBar.style.width = `${Math.round(this.circleProgress * 100)}%`;
    if (shakeBar) shakeBar.style.width = `${Math.round(this.shakeIntensity * 100)}%`;
    
    // Data display
    const updates = {
      'motionType': this.shakeIntensity > 0.5 ? 'Shaking' : 
                   this.circleQuality > 0.4 ? 'Circular' : 'Linear',
      'circleScore': `${Math.round(this.circleQuality * 100)}%`,
      'shakeScore': `${Math.round(this.shakeIntensity * 100)}%`,
      'angularVel': this.lastAngle !== null ? `${Math.round(Math.abs(this.totalRotation) * DEG / Math.max(0.1, (this.lastTime - this.circleStartTime) / 1000))} °/s` : '0 °/s',
      'frequency': `${this.shakeFrequency.toFixed(1)} Hz`,
      'radius': `${Math.round(this.circleRadius * 100)} cm`
    };
    
    Object.entries(updates).forEach(([id, value]) => {
      const el = document.getElementById(id);
      if (el) el.textContent = value;
    });
  }
  
  _onCircleDetected(duration, radius, quality) {
    console.log('🔄 Circle detected!', { duration, radius, quality });
    
    // Visual feedback
    document.body.style.background = 'linear-gradient(135deg,#2196F3 0%,#03DAC6 100%)';
    setTimeout(() => {
      document.body.style.background = 'linear-gradient(135deg,#667eea 0%,#764ba2 100%)';
    }, 600);
    
    // Status update
    const status = document.getElementById('status');
    if (status) {
      status.textContent = '🔄 Circle motion detected!';
      status.className = 'status circle';
      setTimeout(() => {
        status.textContent = 'Ready! Make circles or shakes';
        status.className = 'status active';
      }, 1500);
    }
    
    // Add to history
    this._addToHistory('circle', `Circle: ${duration.toFixed(1)}s, ${Math.round(radius*100)}cm, ${Math.round(quality*100)}%`);
    
    // Haptic feedback
    if ('vibrate' in navigator) navigator.vibrate([100, 50, 100, 50, 100]);
    
    // Fire custom event
    window.dispatchEvent(new CustomEvent('circleDetected', { 
      detail: { duration, radius, quality } 
    }));
    
    this._resetCircleDetection();
  }
  
  _onShakeDetected(intensity, frequency) {
    console.log('🤝 Shake detected!', { intensity, frequency });
    
    // Visual feedback  
    document.body.style.background = 'linear-gradient(135deg,#FF5722 0%,#FF9800 100%)';
    setTimeout(() => {
      document.body.style.background = 'linear-gradient(135deg,#667eea 0%,#764ba2 100%)';
    }, 400);
    
    // Status update
    const status = document.getElementById('status');
    if (status) {
      status.textContent = '🤝 Shake motion detected!';
      status.className = 'status shake';
      setTimeout(() => {
        status.textContent = 'Ready! Make circles or shakes';
        status.className = 'status active';
      }, 1200);
    }
    
    // Add to history
    this._addToHistory('shake', `Shake: intensity ${Math.round(intensity*100)}%, ${frequency.toFixed(1)}Hz`);
    
    // Haptic feedback
    if ('vibrate' in navigator) navigator.vibrate([80, 40, 80]);
    
    // Fire custom event  
    window.dispatchEvent(new CustomEvent('shakeDetected', { 
      detail: { intensity, frequency } 
    }));
  }
  
  _addToHistory(type, text) {
    const history = document.getElementById('history');
    if (history) {
      const div = document.createElement('div');
      div.className = `detection-item ${type}`;
      div.textContent = `${new Date().toLocaleTimeString()}: ${text}`;
      history.appendChild(div);
      history.scrollTop = history.scrollHeight;
    }
  }
}

// Global state
let detector = null;
let isActive = false;

function startDetection() {
  if (isActive) return;
  
  const canvas = document.getElementById('pathCanvas');
  const dot = document.getElementById('motionDot');
  
  detector = new MotionDetector(canvas, dot);
  
  window.addEventListener('devicemotion', onMotionEvent, { passive: true });
  isActive = true;
  
  const status = document.getElementById('status');
  if (status) {
    status.textContent = 'Calibrating... hold still';
    status.className = 'status';
  }
  
  document.getElementById('startBtn').style.display = 'none';
  document.getElementById('stopBtn').style.display = 'inline-block';
  
  // Check for sensor availability
  let hasData = false;
  const checkSensors = () => { hasData = true; };
  window.addEventListener('devicemotion', checkSensors, { passive: true });
  
  setTimeout(() => {
    window.removeEventListener('devicemotion', checkSensors);
    if (!hasData) {
      document.getElementById('sensorNotice').style.display = 'block';
    }
  }, 2000);
}

function stopDetection() {
  if (!isActive) return;
  
  window.removeEventListener('devicemotion', onMotionEvent);
  isActive = false;
  
  const status = document.getElementById('status');
  if (status) {
    status.textContent = 'Detection stopped';
    status.className = 'status';
  }
  
  document.getElementById('startBtn').style.display = 'inline-block';
  document.getElementById('stopBtn').style.display = 'none';
}

function onMotionEvent(event) {
  if (!detector) return;

  // Normalize objects (some browsers return null components)
  const normalizeVec3 = (v) => {
    if (!v) return null;
    const nx = Number.isFinite(v.x) ? v.x : 0;
    const ny = Number.isFinite(v.y) ? v.y : 0;
    const nz = Number.isFinite(v.z) ? v.z : 0;
    return { x: nx, y: ny, z: nz };
  };

  const acceleration = normalizeVec3(event.acceleration);
  const accelerationGravity = normalizeVec3(event.accelerationIncludingGravity);
  const rotationRate = event.rotationRate ? {
    alpha: Number.isFinite(event.rotationRate.alpha) ? event.rotationRate.alpha : 0,
    beta:  Number.isFinite(event.rotationRate.beta)  ? event.rotationRate.beta  : 0,
    gamma: Number.isFinite(event.rotationRate.gamma) ? event.rotationRate.gamma : 0
  } : null;

  // Use event.timeStamp if available; fall back to performance.now()
  const ts = (typeof event.timeStamp === 'number') ? event.timeStamp : performance.now();

  detector.addMotionSample(acceleration, accelerationGravity, rotationRate, ts);
}

// Simple helper hooked to the "Clear History" button
function clearHistory() {
  const history = document.getElementById('history');
  if (history) history.innerHTML = '';

  // Reset visuals and metrics
  if (detector) detector._resetDetection();

  const status = document.getElementById('status');
  if (status) {
    status.textContent = 'Ready! Make circles or shakes';
    status.className = 'status active';
  }

  const notice = document.getElementById('sensorNotice');
  if (notice) notice.style.display = 'none';
}
</script>
</body>
</html>
