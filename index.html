<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circular Motion Detector Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
        }

        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        h1 {
            margin-bottom: 20px;
            font-size: 24px;
            font-weight: 600;
        }

        .status {
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .status.inactive {
            background: rgba(255, 107, 107, 0.2);
            border: 1px solid rgba(255, 107, 107, 0.5);
        }

        .status.active {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid rgba(76, 175, 80, 0.5);
        }

        .status.detecting {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid rgba(255, 193, 7, 0.5);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .data-display {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            text-align: left;
        }

        .confidence-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #FFC107, #FF5722);
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        button {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px;
            transition: all 0.3s ease;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        .detection-history {
            max-height: 150px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 10px;
            margin: 15px 0;
        }

        .detection-item {
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 14px;
        }

        .gyro-visual {
            width: 200px;
            height: 200px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            margin: 20px auto;
            position: relative;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .gyro-dot {
            width: 10px;
            height: 10px;
            background: #4CAF50;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🔄 Circular Motion Tester</h1>
        
        <div id="status" class="status inactive">
            Tap "Start Detection" to begin
        </div>

        <div class="gyro-visual">
            <div id="gyroDot" class="gyro-dot"></div>
        </div>

        <div class="confidence-bar">
            <div id="confidenceBar" class="confidence-fill" style="width: 0%"></div>
        </div>
        <div id="confidenceText">Confidence: 0%</div>

        <button id="startBtn" onclick="startDetection()">Start Detection</button>
        <button id="stopBtn" onclick="stopDetection()" style="display: none;">Stop Detection</button>
        <button onclick="clearHistory()">Clear History</button>

        <div class="data-display">
            <div>Angular Velocity:</div>
            <div id="gyroData">X: 0°/s, Y: 0°/s, Z: 0°/s</div>
            <div>Magnitude: <span id="magnitude">0</span>°/s</div>
        </div>

        <div class="detection-history">
            <strong>Detection History:</strong>
            <div id="history"></div>
        </div>
    </div>

    <script>
        class CircularMotionDetector {
          constructor() {
            this.samples = [];             // {timestamp, dt, x,y,z}
            this.maxBufferMs = 4000;       // keep ~4 seconds of history
      
            // Detection targets / gates (tune these if needed)
            this.targetRevolutionDeg = 330;  // "almost full" turn
            this.windowSec = 3.0;            // integrate over last N seconds
            this.minDurationSec = 0.5;       // avoid hair-trigger bursts
            this.maxDurationSec = 4.0;
      
            this.noiseFloor = 1.5;           // deg/s: below this = 0
            this.minAvgVel = 20;             // deg/s average activity gate
            this.maxAvgVel = 900;            // ignore insane spikes
      
            this.axisCoherenceMin = 0.70;    // energy aligned with dominant axis
            this.signCoherenceMin = 0.85;    // fraction of time turning same direction
      
            this.rateLimitMs = 2000;
            this.lastDetection = 0;
      
            // UI smoothing (dot)
            this.uiX = 0; this.uiY = 0;
            this.uiAlpha = 0.12;
            this.visualDeadzone = 1.0;
            this.uiScale = 1.2;
          }
      
          addReading(x, y, z) {
            const now = Date.now();
            const prev = this.samples.length ? this.samples[this.samples.length - 1] : null;
            const dt = prev ? Math.max(0.001, (now - prev.timestamp) / 1000) : 0.016;
      
            this.samples.push({ timestamp: now, dt, x, y, z });
            // Trim old samples by time
            const cutoff = now - this.maxBufferMs;
            while (this.samples.length && this.samples[0].timestamp < cutoff) {
              this.samples.shift();
            }
      
            this.updateUI({ x, y });
      
            // Try detection each tick
            const result = this.detectFullRevolution();
            const progressPct = Math.round(result.progress * 100);
      
            // Update the existing bar/text as "progress"
            document.getElementById('confidenceBar').style.width = progressPct + '%';
            document.getElementById('confidenceText').textContent = `Confidence: ${progressPct}%`;
      
            if (result.detected) {
              const nowMs = Date.now();
              if (nowMs - this.lastDetection > this.rateLimitMs) {
                this.onCircularMotionDetected(result.progress);
                this.lastDetection = nowMs;
                // After a fire, clear older samples so we don't double-trigger on the same spin
                this._clearWindow();
              }
            }
          }
      
          updateUI(reading) {
            document.getElementById('gyroData').textContent =
              `X: ${reading.x.toFixed(1)}°/s, Y: ${reading.y.toFixed(1)}°/s, Z: ${0}°/s`;
            const magnitude = Math.sqrt(reading.x**2 + reading.y**2 + 0);
            document.getElementById('magnitude').textContent = magnitude.toFixed(1);
      
            // Calm velocity dot (UI only; still not a "path")
            this.uiX += this.uiAlpha * (reading.x - this.uiX);
            this.uiY += this.uiAlpha * (reading.y - this.uiY);
            const visX = Math.abs(this.uiX) < this.visualDeadzone ? 0 : this.uiX;
            const visY = Math.abs(this.uiY) < this.visualDeadzone ? 0 : this.uiY;
      
            const dot = document.getElementById('gyroDot');
            const maxOffset = 90;
            const offsetX = Math.max(-maxOffset, Math.min(maxOffset, visX * this.uiScale));
            const offsetY = Math.max(-maxOffset, Math.min(maxOffset, visY * this.uiScale));
            dot.style.transform = `translate(calc(-50% + ${offsetX}px), calc(-50% + ${offsetY}px))`;
          }
      
          // ---------- Core detector: "Full revolution" ----------
          detectFullRevolution() {
            const window = this._getWindow(this.windowSec);
            if (window.length < 10) return { detected: false, progress: 0 };
      
            const duration = (window[window.length - 1].timestamp - window[0].timestamp) / 1000;
            if (duration < this.minDurationSec || duration > this.maxDurationSec) {
              return { detected: false, progress: 0 };
            }
      
            // Apply deadzone
            const W = window.map(s => ({
              dt: s.dt,
              x: this._dz(s.x),
              y: this._dz(s.y),
              z: this._dz(s.z)
            }));
      
            // Activity gate
            const avgVel = this._mean(W.map(v => Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z)));
            if (avgVel < this.minAvgVel || avgVel > this.maxAvgVel) return { detected: false, progress: 0 };
      
            // Estimate dominant axis of rotation (weighted by |ω|)
            const axis = this._dominantAxis(W);
            if (!axis) return { detected: false, progress: 0 };
      
            // Project onto axis, integrate signed angle, and measure coherences
            const proj = [];
            let sumPar = 0;          // ∑ ω_parallel * dt  (degrees)
            let energyPar = 0;       // ∑ ω_parallel^2
            let energyTotal = 0;     // ∑ ||ω||^2
      
            for (const s of W) {
              const par = s.x * axis[0] + s.y * axis[1] + s.z * axis[2];
              proj.push({ par, dt: s.dt });
              sumPar += par * s.dt;
              energyPar += par * par;
              energyTotal += s.x*s.x + s.y*s.y + s.z*s.z;
            }
      
            // Axis coherence: how much energy lies along the dominant axis
            const axisCoherence = energyTotal > 0 ? (energyPar / energyTotal) : 0;
      
            // Direction (sign) coherence: mostly same sign as the dominant sign?
            const domSign = sumPar >= 0 ? 1 : -1;
            let same = 0, total = 0;
            for (const p of proj) {
              if (Math.abs(p.par) < this.noiseFloor) continue;
              total += p.dt;
              if (p.par * domSign > 0) same += p.dt;
            }
            const signCoherence = total > 0 ? same / total : 0;
      
            // Progress toward full revolution
            const progress = Math.min(1, Math.abs(sumPar) / this.targetRevolutionDeg);
      
            // Decision
            const detected =
              progress >= 1.0 &&
              axisCoherence >= this.axisCoherenceMin &&
              signCoherence >= this.signCoherenceMin;
      
            return { detected, progress };
          }
      
          onCircularMotionDetected(progress) {
            console.log(`🔄 Full revolution detected! Progress: ${(progress*100).toFixed(0)}%`);
            document.body.style.background = 'linear-gradient(135deg, #4CAF50 0%, #45a049 100%)';
            setTimeout(() => { document.body.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)'; }, 1000);
      
            if ('vibrate' in navigator) navigator.vibrate([200, 100, 200]);
      
            const historyItem = document.createElement('div');
            historyItem.className = 'detection-item';
            historyItem.textContent = `${new Date().toLocaleTimeString()}: Full revolution`;
            document.getElementById('history').appendChild(historyItem);
      
            const status = document.getElementById('status');
            status.textContent = `🎉 FULL REVOLUTION!`;
            status.className = 'status detecting';
            setTimeout(() => { status.textContent = 'Listening for circular motions...'; status.className = 'status active'; }, 2000);
          }
      
          // ---------- Helpers ----------
          _getWindow(sec) {
            const now = Date.now();
            const start = now - sec * 1000;
            // Collect only recent samples (preserve dt)
            const out = [];
            for (let i = this.samples.length - 1; i >= 0; i--) {
              const s = this.samples[i];
              if (s.timestamp < start) break;
              out.push(s);
            }
            return out.reverse();
          }
      
          _clearWindow() {
            const now = Date.now();
            const keepStart = now - 500; // keep just a very short tail
            this.samples = this.samples.filter(s => s.timestamp >= keepStart);
          }
      
          _dz(v) { return Math.abs(v) < this.noiseFloor ? 0 : v; }
          _mean(a) { return a.length ? a.reduce((x,y)=>x+y,0)/a.length : 0; }
      
          _dominantAxis(W) {
            // Weighted by |ω| to prefer stronger samples
            let sx = 0, sy = 0, sz = 0, wsum = 0;
            for (const s of W) {
              const mag = Math.sqrt(s.x*s.x + s.y*s.y + s.z*s.z);
              if (mag === 0) continue;
              sx += (s.x / mag) * mag;
              sy += (s.y / mag) * mag;
              sz += (s.z / mag) * mag;
              wsum += mag;
            }
            if (wsum === 0) return null;
            const n = Math.sqrt(sx*sx + sy*sy + sz*sz);
            if (n < 1e-6) return null;
            return [sx/n, sy/n, sz/n]; // unit vector
          }
        }
      
        const detector = new CircularMotionDetector();
        let isDetectionActive = false;
      
        // iOS permission for motion sensors (unchanged)
        function startDetection() {
          const needsPermission =
            typeof DeviceMotionEvent !== 'undefined' &&
            typeof DeviceMotionEvent.requestPermission === 'function';
      
          if (needsPermission) {
            DeviceMotionEvent.requestPermission()
              .then((state) => {
                if (state === 'granted') startGyroscope();
                else alert('Motion permission denied. Please allow in browser settings.');
              })
              .catch((err) => { console.error(err); alert('Permission request failed.'); });
          } else {
            startGyroscope();
          }
        }
      
        function startGyroscope() {
          if (isDetectionActive) return;
          window.addEventListener('devicemotion', handleMotion);
          isDetectionActive = true;
      
          document.getElementById('status').textContent = 'Listening for circular motions...';
          document.getElementById('status').className = 'status active';
          document.getElementById('startBtn').style.display = 'none';
          document.getElementById('stopBtn').style.display = 'inline-block';
      
          console.log('🚀 Full-revolution detection started');
        }
      
        function stopDetection() {
          if (!isDetectionActive) return;
          window.removeEventListener('devicemotion', handleMotion);
          isDetectionActive = false;
      
          document.getElementById('status').textContent = 'Detection stopped';
          document.getElementById('status').className = 'status inactive';
          document.getElementById('startBtn').style.display = 'inline-block';
          document.getElementById('stopBtn').style.display = 'none';
      
          console.log('⏹️ Detection stopped');
        }
      
        function handleMotion(event) {
          if (!isDetectionActive) return;
          const rr = event.rotationRate;
          if (rr) {
            // Keep degrees/sec; map beta->X, gamma->Y, alpha->Z
            detector.addReading(
              rr.beta  || 0,  // X
              rr.gamma || 0,  // Y
              rr.alpha || 0   // Z
            );
          }
        }
      
        function clearHistory() {
          document.getElementById('history').innerHTML = '';
          document.getElementById('confidenceBar').style.width = '0%';
          document.getElementById('confidenceText').textContent = 'Confidence: 0%';
        }
      
        window.addEventListener('load', () => {
          console.log('📱 Spin your wrist (keep turning in the SAME direction). Progress climbs to ~100%, then triggers.');
        });
      </script>
      
      
      
</body>
</html>
