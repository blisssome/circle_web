<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circular Motion Detector Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
        }

        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        h1 {
            margin-bottom: 20px;
            font-size: 24px;
            font-weight: 600;
        }

        .status {
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .status.inactive {
            background: rgba(255, 107, 107, 0.2);
            border: 1px solid rgba(255, 107, 107, 0.5);
        }

        .status.active {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid rgba(76, 175, 80, 0.5);
        }

        .status.detecting {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid rgba(255, 193, 7, 0.5);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .data-display {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            text-align: left;
        }

        .confidence-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #FFC107, #FF5722);
            transition: width 0.3s ease;
            border-radius: 10px;
        }

        button {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px;
            transition: all 0.3s ease;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        button:active {
            transform: translateY(0);
        }

        .detection-history {
            max-height: 150px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 10px;
            margin: 15px 0;
        }

        .detection-item {
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 14px;
        }

        .gyro-visual {
            width: 200px;
            height: 200px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            margin: 20px auto;
            position: relative;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .gyro-dot {
            width: 10px;
            height: 10px;
            background: #4CAF50;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🔄 Circular Motion Tester</h1>
        
        <div id="status" class="status inactive">
            Tap "Start Detection" to begin
        </div>

        <div class="gyro-visual">
            <div id="gyroDot" class="gyro-dot"></div>
        </div>

        <div class="confidence-bar">
            <div id="confidenceBar" class="confidence-fill" style="width: 0%"></div>
        </div>
        <div id="confidenceText">Confidence: 0%</div>

        <button id="startBtn" onclick="startDetection()">Start Detection</button>
        <button id="stopBtn" onclick="stopDetection()" style="display: none;">Stop Detection</button>
        <button onclick="clearHistory()">Clear History</button>

        <div class="data-display">
            <div>Angular Velocity:</div>
            <div id="gyroData">X: 0°/s, Y: 0°/s, Z: 0°/s</div>
            <div>Magnitude: <span id="magnitude">0</span>°/s</div>
        </div>

        <div class="detection-history">
            <strong>Detection History:</strong>
            <div id="history"></div>
        </div>
    </div>

    <script>
        class CircularMotionDetector {
          constructor() {
            this.gyroBuffer = [];
            this.bufferSize = 100;
      
            this.minCircularVelocity = 30.0;   // deg/s
            this.maxCircularVelocity = 800.0;  // quick wrist twists can exceed 200
      
            this.minCirclePoints = 20;
            this.completenessThreshold = 0.7;
            this.isAnalyzing = false;
            this.lastDetection = 0;
            this.rateLimitMs = 3000;
      
            // --- noise + UI smoothing ---
            this.noiseFloor = 1.2;        // deg/s: treat smaller as sensor noise
            this.zeroEps   = this.noiseFloor;
            this.uiX = 0; this.uiY = 0;
            this.uiAlpha = 0.12;          // stronger smoothing for a calm dot
            this.visualDeadzone = 1.0;    // deg/s after smoothing
            this.uiScale = 1.2;           // reduce dot sensitivity
          }
      
          addReading(x, y, z) {
            // x,y,z already in deg/s from event.rotationRate
            const reading = { timestamp: Date.now(), x, y, z };
            this.gyroBuffer.push(reading);
            if (this.gyroBuffer.length > this.bufferSize) this.gyroBuffer.shift();
      
            this.updateUI(reading);
      
            if (this.gyroBuffer.length >= this.minCirclePoints && !this.isAnalyzing) {
              this.checkForCircularMotion();
            }
          }
      
          updateUI(reading) {
            document.getElementById('gyroData').textContent =
              `X: ${reading.x.toFixed(1)}°/s, Y: ${reading.y.toFixed(1)}°/s, Z: ${reading.z.toFixed(1)}°/s`;
      
            const magnitude = Math.sqrt(reading.x**2 + reading.y**2 + reading.z**2);
            document.getElementById('magnitude').textContent = magnitude.toFixed(1);
      
            // Smooth the dot, then apply a visual deadzone
            this.uiX += this.uiAlpha * (reading.x - this.uiX);
            this.uiY += this.uiAlpha * (reading.y - this.uiY);
            const visX = Math.abs(this.uiX) < this.visualDeadzone ? 0 : this.uiX;
            const visY = Math.abs(this.uiY) < this.visualDeadzone ? 0 : this.uiY;
      
            const dot = document.getElementById('gyroDot');
            const maxOffset = 90;
            const offsetX = Math.max(-maxOffset, Math.min(maxOffset, visX * this.uiScale));
            const offsetY = Math.max(-maxOffset, Math.min(maxOffset, visY * this.uiScale));
            dot.style.transform = `translate(calc(-50% + ${offsetX}px), calc(-50% + ${offsetY}px))`;
          }
      
          checkForCircularMotion() {
            this.isAnalyzing = true;
            try {
              const r1 = this.detectByAngularMomentum();
              const r2 = this.detectByFrequency();
              const r3 = this.detectByPattern();
      
              const confidence = (r1.confidence * 0.4) + (r2.confidence * 0.3) + (r3.confidence * 0.3);
      
              document.getElementById('confidenceBar').style.width = `${confidence * 100}%`;
              document.getElementById('confidenceText').textContent = `Confidence: ${(confidence * 100).toFixed(1)}%`;
      
              const now = Date.now();
              if (confidence > 0.7 && (now - this.lastDetection) > this.rateLimitMs) {
                this.onCircularMotionDetected(confidence);
                this.lastDetection = now;
              }
            } finally {
              this.isAnalyzing = false;
            }
          }
      
          detectByAngularMomentum() {
            if (this.gyroBuffer.length < this.minCirclePoints) {
              return { detected: false, confidence: 0.0 };
            }
            const recent = this.gyroBuffer.slice(-50);
            const mags = recent.map(r => Math.sqrt(r.x*r.x + r.y*r.y + r.z*r.z));
      
            const avgMag = mags.reduce((a,b)=>a+b,0) / mags.length;
            const variance = this.calculateVariance(mags);
      
            const magnitudeConsistency = 1.0 - Math.min(1.0, variance / 1000.0);
            const magnitudeScore = this.scoreInRange(avgMag, this.minCircularVelocity, this.maxCircularVelocity);
      
            // >>> key change: suppress "good consistency" when there is no motion
            const activity = this.scoreInRange(avgMag, this.noiseFloor * 2, this.maxCircularVelocity);
            const confidence = activity * (magnitudeConsistency * 0.6 + magnitudeScore * 0.4);
            // <<<
      
            return { detected: confidence > 0.5, confidence };
          }
      
          detectByFrequency() {
            if (this.gyroBuffer.length < this.minCirclePoints) {
              return { detected: false, confidence: 0.0 };
            }
            const recent = this.gyroBuffer.slice(-50);
            const xValues = recent.map(r => this._deadzone(r.x));
            const yValues = recent.map(r => this._deadzone(r.y));
            const zValues = recent.map(r => this._deadzone(r.z));
      
            const xCross = this.countZeroCrossings(xValues);
            const yCross = this.countZeroCrossings(yValues);
            const zCross = this.countZeroCrossings(zValues);
      
            const avgCrossings = (xCross + yCross + zCross) / 3.0;
            const periodicityScore = this.scoreInRange(avgCrossings, 2.0, 6.0);
            return { detected: periodicityScore > 0.5, confidence: periodicityScore };
          }
      
          detectByPattern() {
            if (this.gyroBuffer.length < this.minCirclePoints) {
              return { detected: false, confidence: 0.0 };
            }
            const recent = this.gyroBuffer.slice(-40);
            const angles = recent.map(r => Math.atan2(r.y, r.x));
      
            const totalRotation = this.calculateTotalRotation(angles);
            const completeness = Math.min(1.0, totalRotation / (2 * Math.PI));
            if (completeness < this.completenessThreshold) return { detected: false, confidence: 0.0 };
      
            const smoothness = this.calculateRotationSmoothness(angles);
            const confidence = completeness * 0.7 + smoothness * 0.3;
            return { detected: confidence > 0.6, confidence };
          }
      
          _deadzone(v) { return Math.abs(v) < this.noiseFloor ? 0 : v; }
      
          calculateVariance(values) {
            const mean = values.reduce((a,b)=>a+b,0) / values.length;
            const sq = values.map(v => (v - mean) * (v - mean));
            return sq.reduce((a,b)=>a+b,0) / values.length;
          }
      
          scoreInRange(value, min, max) {
            if (value < min) return Math.max(0.0, 1.0 - (min - value) / (min || 1));
            if (value > max) return Math.max(0.0, 1.0 - (value - max) / (max || 1));
            return 1.0;
          }
      
          countZeroCrossings(values) {
            let crossings = 0;
            for (let i = 1; i < values.length; i++) {
              const a = values[i-1], b = values[i];
              if ((a > 0 && b <= 0) || (a < 0 && b >= 0)) crossings++;
            }
            return crossings;
          }
      
          calculateTotalRotation(angles) {
            let total = 0;
            for (let i = 1; i < angles.length; i++) {
              let d = angles[i] - angles[i-1];
              if (d >  Math.PI) d -= 2*Math.PI;
              if (d < -Math.PI) d += 2*Math.PI;
              total += Math.abs(d);
            }
            return total;
          }
      
          calculateRotationSmoothness(angles) {
            if (angles.length < 3) return 0.0;
            let totalCurv = 0;
            for (let i = 1; i < angles.length - 1; i++) {
              totalCurv += Math.abs(angles[i+1] - 2*angles[i] + angles[i-1]);
            }
            return Math.max(0.0, 1.0 - totalCurv / angles.length);
          }
      
          onCircularMotionDetected(confidence) {
            console.log(`🔄 Circular motion detected! Confidence: ${(confidence * 100).toFixed(1)}%`);
            document.body.style.background = 'linear-gradient(135deg, #4CAF50 0%, #45a049 100%)';
            setTimeout(() => {
              document.body.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            }, 1000);
            if ('vibrate' in navigator) navigator.vibrate([200, 100, 200]);
      
            const historyItem = document.createElement('div');
            historyItem.className = 'detection-item';
            historyItem.textContent = `${new Date().toLocaleTimeString()}: Confidence ${(confidence * 100).toFixed(1)}%`;
            document.getElementById('history').appendChild(historyItem);
      
            const status = document.getElementById('status');
            status.textContent = `🎉 CIRCULAR MOTION DETECTED! (${(confidence * 100).toFixed(1)}%)`;
            status.className = 'status detecting';
            setTimeout(() => { status.textContent = 'Listening for circular motions...'; status.className = 'status active'; }, 2000);
          }
        }
      
        const detector = new CircularMotionDetector();
        let isDetectionActive = false;
      
        // iOS permission for motion sensors
        function startDetection() {
          const needsPermission =
            typeof DeviceMotionEvent !== 'undefined' &&
            typeof DeviceMotionEvent.requestPermission === 'function';
      
          if (needsPermission) {
            DeviceMotionEvent.requestPermission()
              .then((state) => {
                if (state === 'granted') startGyroscope();
                else alert('Motion permission denied. Please allow in browser settings.');
              })
              .catch((err) => { console.error(err); alert('Permission request failed.'); });
          } else {
            startGyroscope();
          }
        }
      
        function startGyroscope() {
          if (isDetectionActive) return;
          window.addEventListener('devicemotion', handleMotion);
          isDetectionActive = true;
          document.getElementById('status').textContent = 'Listening for circular motions...';
          document.getElementById('status').className = 'status active';
          document.getElementById('startBtn').style.display = 'none';
          document.getElementById('stopBtn').style.display = 'inline-block';
          console.log('🚀 Circular motion detection started');
        }
      
        function stopDetection() {
          if (!isDetectionActive) return;
          window.removeEventListener('devicemotion', handleMotion);
          isDetectionActive = false;
          document.getElementById('status').textContent = 'Detection stopped';
          document.getElementById('status').className = 'status inactive';
          document.getElementById('startBtn').style.display = 'inline-block';
          document.getElementById('stopBtn').style.display = 'none';
          console.log('⏹️ Circular motion detection stopped');
        }
      
        function handleMotion(event) {
          if (!isDetectionActive) return;
          const rr = event.rotationRate;
          if (rr) {
            // Correct axes; keep degrees/sec (no extra conversion)
            detector.addReading(
              rr.beta  || 0, // X
              rr.gamma || 0, // Y
              rr.alpha || 0  // Z
            );
          }
        }
      
        function clearHistory() {
          document.getElementById('history').innerHTML = '';
          document.getElementById('confidenceBar').style.width = '0%';
          document.getElementById('confidenceText').textContent = 'Confidence: 0%';
        }
      
        window.addEventListener('load', () => {
          console.log('📱 Ready. Idle confidence should hover near 0–5%, dot barely moves.');
        });
      </script>
      
      
</body>
</html>
